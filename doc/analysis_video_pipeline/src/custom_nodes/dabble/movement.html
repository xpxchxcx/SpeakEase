<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement API documentation</title>
<meta name="description" content="Docstring for the movement.py module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement</code></h1>
</header>
<section id="section-intro">
<p>Docstring for the movement.py module</p>
<p>This module implements a custom Node class extended from PeekingDuck's AbstractNode.</p>
<h2 id="usage">Usage</h2>
<p>This module should be part of a package that follows the file structure as specified by the
<a href="https://peekingduck.readthedocs.io/en/stable/tutorials/03_custom_nodes.html">PeekingDuck documentation</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Docstring for the movement.py module

This module implements a custom Node class extended from PeekingDuck&#39;s AbstractNode.

Usage
-----
This module should be part of a package that follows the file structure as specified by the
[PeekingDuck documentation](https://peekingduck.readthedocs.io/en/stable/tutorials/03_custom_nodes.html).
&#34;&#34;&#34;

# pylint: disable=invalid-name, logging-format-interpolation

import logging
from math import acos, pi, sqrt
from typing import Any, Mapping, Optional, Tuple

import cv2
from peekingduck.pipeline.nodes.abstract_node import AbstractNode


Coord = Tuple[int, int]  # Type-hinting alias for coordinates


class Node(AbstractNode):
    &#34;&#34;&#34;Custom node to display PoseNet&#39;s skeletal keypoints and pose category statistics onto the video feed&#34;&#34;&#34;

    # TODO write documentation for custom node class

    # Define colours for display purposes
    # Note: OpenCV loads file in BGR format
    _WHITE = (255, 255, 255)
    _YELLOW = (0, 255, 255)
    _BLUE = (255, 0, 0)

    # Define font properties for display purposes
    _FONT_FACE = cv2.FONT_HERSHEY_SIMPLEX  # pylint: disable=no-member
    _FONT_SCALE = 1
    _FONT_THICKNESS = 2

    # Define constants for PoseNet keypoint detection
    _THRESHOLD = 0.6
    # PoseNet&#39;s skeletal key points
    # https://discuss.tensorflow.org/uploads/default/original/2X/9/951fd6aaf5fec83500fe2e9891348416e13b66dd.png
    (
        KP_NOSE,
        KP_LEFT_EYE,
        KP_RIGHT_EYE,
        KP_LEFT_EAR,
        KP_RIGHT_EAR,
        KP_LEFT_SHOULDER,
        KP_RIGHT_SHOULDER,
        KP_LEFT_ELBOW,
        KP_RIGHT_ELBOW,
        KP_LEFT_WRIST,
        KP_RIGHT_WRIST,
        KP_LEFT_HIP,
        KP_RIGHT_HIP,
        KP_LEFT_KNEE,
        KP_RIGHT_KNEE,
        KP_LEFT_FOOT,
        KP_RIGHT_FOOT
    ) = range(17)

    def __init__(
            self,
            config: Optional[Mapping[str, Any]] = None,
            **kwargs
    ) -&gt; None:
        &#34;&#34;&#34;Initialises the custom node class

        Parameters
        ----------
        config : dict, optional
            Node custom configuration

        Other Parameters
        ----------------
        **kwargs
            Keyword arguments for instantiating the AbstractNode parent class
        &#34;&#34;&#34;

        super().__init__(config, node_path=__name__, **kwargs)  # type: ignore
        self._logger = logging.getLogger(__name__)

        # Define variables used for tracking
        self._img = None
        self._arm_fold_count = self._leaning_count = self._face_touch_count = self._total_frame_count = 0

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Height of the displayed image, specified in pixels

        Returns
        -------
        int
            Height of the displayed image, specified in pixels.

            Returns ``ERROR_OUTPUT`` instead if the image is undefined.
        &#34;&#34;&#34;

        return self.ERROR_OUTPUT if self._img is None else self._img.shape[0]

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Width of the displayed image, specified in pixels

        Returns
        -------
        int
            Width of the displayed image, specified in pixels.

            Returns ``ERROR_OUTPUT`` instead if the image is undefined.
        &#34;&#34;&#34;

        return self.ERROR_OUTPUT if self._img is None else self._img.shape[1]

    @property
    def ERROR_OUTPUT(self) -&gt; int:
        &#34;&#34;&#34;Defines the default output for encountered errors as `-1`

        Computational functions will return non-negative input.

        Returns
        -------
        int
            `-1`, the default output.
        &#34;&#34;&#34;

        return -1

    def _map_coord_onto_img(
            self,
            x: float,
            y: float
    ) -&gt; Coord:
        &#34;&#34;&#34;Maps relative coordinates onto the displayed image

        This function assumes that the displayed image has already been defined.

        Parameters
        ----------
        x : float
            Relative horizontal position of the coordinate; 0 &lt;= `x` &lt;= 1
        y : float
            Relative vertical position of the coordinate; 0 &lt;= `y` &lt;= 1

        Returns
        -------
        `Coord`
            Absolute coordinate (`x1`, `y1`) on the image; 0 &lt;= `x1` &lt;= `width` and 0 &lt;= `y1` &lt;= `height`.

            Returns ``(ERROR_OUTPUT, ERROR_OUTPUT)`` if the image has not been defined.
       &#34;&#34;&#34;

        # Check if image is defined
        if self.width == self.ERROR_OUTPUT or self.height == self.ERROR_OUTPUT:
            self.logger.error(&#39;_map_coord_onto_img() trying to access image but it has not been defined yet.&#39;)
            return self.ERROR_OUTPUT, self.ERROR_OUTPUT

        return round(x * self.width), round(y * self.height)

    def _obtain_keypoint(
            self,
            keypoint: Tuple[float, float],
            score: float
    ) -&gt; Optional[Coord]:
        &#34;&#34;&#34;Obtains a detected PoseNet keypoint if its confidence score meets or exceeds the threshold

        Parameters
        ----------
        keypoint : tuple of floats
            Relative coordinate (`x`, `y`) of the detected PoseNet keypoint;
                0 &lt;= `x` &lt;= 1 and 0 &lt;= `y` &lt;= 1
        score : float
            Confidence score of the detected PoseNet keypoint

        Returns
        -------
        `Coord`, optional
            Absolute coordinates of the detected PoseNet keypoint
                if its confidence score meets or exceeds the threshold confidence
        &#34;&#34;&#34;

        return None if score &lt; self._THRESHOLD else self._map_coord_onto_img(*keypoint)

    def _display_text(
        self,
        x: int,
        y: int,
        text: str,
        font_colour: Tuple[int, int, int],
        *,
        font_face: int = _FONT_FACE,
        font_scale: float = _FONT_SCALE,
        font_thickness: int = _FONT_THICKNESS
    ) -&gt; None:
        &#34;&#34;&#34;Displays text at a specified coordinate on top of the displayed image

        Parameters
        ----------
        x : int
            x-coordinate to display the text at
        y : int
            y-coordinate to display the text at
        text : str
            Text to display
        font_colour : tuple of ints
            Colour of the text to display, specified in BGR format

        Other Parameters
        ----------------
        font_face : int, default=`_FONT_FACE`
            Font type of the text to display.

            Limited to a subset of Hershey Fonts as
                [supported by OpenCV](https://stackoverflow.com/questions/371910008/load-truetype-font-to-opencv).
        font_scale : float
            Relative size of the text to display
        font_thickness : int
            Relative thickness of the text to display
        &#34;&#34;&#34;

        # Check if image is defined
        if self._img is None:
            self.logger.error(&#39;_display_text() trying to access image but it has not been defined yet.&#39;)
            return

        cv2.putText(  # pylint: disable=no-member
            img=self._img,  # type: ignore
            text=text,
            org=(x, y),
            fontFace=font_face,
            fontScale=font_scale,
            color=font_colour,
            thickness=font_thickness
        )

    def _display_bbox_info(
            self,
            bbox: Tuple[int, int, int, int],
            score: float,
            *,
            arms_folded: bool = False,
            is_leaning: bool = False,
            face_touched: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Displays the information associated with the given bounding box

        Parameters
        ----------
        bbox : tuple of ints
            Bounding box, represented by its top-left (`x1`, `y1`) and bottom-right (`x2`, `y2`) coordinates.

            The parameter `bbox` is specified in the format (`x1`, `y1`, `x2`, `y2`);
                0 &lt;= `x1` &lt;= `x2` &lt;= `width` and 0 &lt;= `y1` &lt;= `y2` &lt;= `height`
        score : float
            Confidence score of the bounding box
        arms_folded : bool, default=False
            ``True`` if the person is detected to have folded their arms, ``False`` otherwise
        is_leaning : bool, default=False
            ``True``if the person is detected to be leaning to one side, ``False`` otherwise
        face_touched : bool, default=False
            ``True`` if the person is detected to be touching their face, ``False`` otherwise

        Notes
        -----
        All information will be displayed in the bottom-left corner (`x1`, `y2`) of the bounding box.

        This information includes the following:

        - Confidence score of the bounding box
        - Whether the arms are folded
        - Whether the person is leaning too much to one side
        - Whether the person is touching his/her face
        &#34;&#34;&#34;

        # Initialise constants
        num_lines = 3  # default number of &#39;lines&#39; above the bottom-left coordinate
        line_height = round(30 * self._FONT_SCALE)  # height of each &#39;line&#39; in pixels; 30 is arbitrary

        # Obtain bottom-left coordinate of bounding box
        x1, y1, x2, y2 = bbox
        x, _ = self._map_coord_onto_img(x1, y1)
        _, y = self._map_coord_onto_img(x2, y2)

        # Display information
        self._display_text(x, y - num_lines * line_height, f&#39;BBox {score:0.2f}&#39;, self._WHITE)
        if arms_folded:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Arms Folded&#39;, self._BLUE)
        if is_leaning:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Leaning&#39;, self._BLUE)
        if face_touched:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Touching Face&#39;, self._BLUE)

    def angle_between_vectors_in_rad(
            self,
            x1: int,
            y1: int,
            x2: int,
            y2: int
    ) -&gt; float:
        &#34;&#34;&#34;Obtains the (smaller) angle between two non-zero vectors in radians

        The angle \\( \\Theta \\) is computed via the cosine rule (see the Notes section).

        Parameters
        ----------
        x1 : int
            The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the x-axis
        y1 : int
            The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the y-axis
        x2 : int
            The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the x-axis
        y2 : int
            The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the y-axis

        Returns
        -------
        float
            The (smaller) angle \\( \\Theta \\) between
                \\( \\overrightarrow{ V_{1} } \\) and
                \\( \\overrightarrow{ V_{2} } \\).

            Returns ``ERROR_OUTPUT`` instead if:

            - Either one or both of
                \\( \\overrightarrow{ V_{1} } = \\overrightarrow{0} \\) and
                \\( \\overrightarrow{ V_{2} } = \\overrightarrow{0} \\)
            - \\( \\cos \\Theta \\notin [-1, 1] \\)

        Notes
        -----
        The cosine of the (smaller) angle between two vectors
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} x_{1} \\\\ y_{1} \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} x_{2} \\\\ y_{2} \\end{pmatrix} \\)
        is calculated by:

        $$
        \\cos \\Theta
            = \\frac { \\overrightarrow{ V_{1} } \\cdot \\overrightarrow{ V_{2} } }
                    {\\left\\| \\overrightarrow{V_{1}} \\right\\| \\left\\| \\overrightarrow{V_{2}} \\right\\|}
            = \\frac {x_{1}x_{2} + y_{1}y_{2}}
                    {\\sqrt {{x_{1}}^2 + {y_{1}}^2} \\sqrt {{x_{2}}^2 + {y_{2}}^2}}
            ,\\ 0 \\le \\Theta \\le \\pi
        $$

        Hence, the angle \\( \\Theta \\) between
            \\( \\overrightarrow{ V_{1} } \\) and
            \\( \\overrightarrow{ V_{2} } \\)
        can be calculated by taking the inverse cosine of the result.

        Examples
        --------
        &gt;&gt;&gt; node = Node()

        The angle between two orthogonal vectors is \\( \\frac {\\pi} {2} \\).

        &gt;&gt;&gt; v1 = (0, 1)
        &gt;&gt;&gt; v2 = (1, 0)
        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v2)
        1.5707963267948966
        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v2, *v1)
        1.5707963267948966

        The angle between two parallel vectors is `0`.

        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v1)
        0.0
        &#34;&#34;&#34;

        # Check for zero vectors
        if x1 == y1 == 0 or x2 == y2 == 0:
            self.logger.error(
                f&#39;One or more zero vectors v1 = ({x1}, {y1}) and &#39; +
                f&#39;v2 = ({x2}, {y2}) were passed into angle_between_vectors_in_rad().&#39;
            )
            return self.ERROR_OUTPUT

        # Compute the cosine value
        dot_prod = x1 * x2 + y1 * y2
        v1_magnitude = sqrt(x1 * x1 + y1 * y1)
        v2_magnitude = sqrt(x2 * x2 + y2 * y2)
        cos_value = dot_prod / (v1_magnitude * v2_magnitude)

        # Check if the cosine value is within acos domain of [-1, 1]
        if abs(cos_value) &gt; 1:
            self.logger.error(
                f&#39;angle_between_vectors_in_rad() obtained cosine value {cos_value} &#39; +
                &#39;that is not within acos domain [-1, 1]. &#39; +
                f&#39;v1 Â· v2 = {dot_prod}, ||v1|| = {v1_magnitude}, ||v2|| = {v2_magnitude}&#39;
            )
            return self.ERROR_OUTPUT

        return acos(cos_value)

    def are_arms_folded(
            self,
            left_shoulder: Optional[Coord],
            left_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_shoulder: Optional[Coord],
            right_elbow: Optional[Coord],
            right_wrist: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the arms of the given pose are folded

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            (`x`, `y`) coordinate of the left shoulder
        left_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the left elbow
        left_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the left wrist
        right_shoulder : `Coord`, optional
            (`x`, `y`) coordinate of the right shoulder
        right_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the right elbow
        right_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the right wrist

        Returns
        -------
        bool
            ``True`` if both arms are folded, ``False`` otherwise

        Notes
        -----
        The line from the shoulder to the elbow intersects the line from the wrist to the elbow at the elbow.

        An arm is considered folded if:

        - The angle that the two lines make with each other is less than `120` degrees
        - The x-coordinate of the wrist lies in between the x-coordinates of the shoulders
        - The y-coordinate of the wrist lies below the y-coordinate of either shoulder
        - The distance between the wrist and the elbow is at least half that between the shoulders
        &#34;&#34;&#34;

        # Check if keypoints are defined
        if left_shoulder is None or \
                left_elbow is None or \
                left_wrist is None or \
                right_shoulder is None or \
                right_elbow is None or \
                right_wrist is None:
            return False

        # Obtain coordinates
        left_shoulder_x, left_shoulder_y = left_shoulder
        right_shoulder_x, right_shoulder_y = right_shoulder
        left_elbow_x, left_elbow_y = left_elbow
        right_elbow_x, right_elbow_y = right_elbow
        left_wrist_x, left_wrist_y = left_wrist
        right_wrist_x, right_wrist_y = right_wrist

        # Calculate relevant vectors
        left_shoulder_elbow_vec = (
            left_shoulder_x - left_elbow_x,
            left_shoulder_y - left_elbow_y
        )
        left_wrist_elbow_vec = (
            left_wrist_x - left_elbow_x,
            left_wrist_y - left_elbow_y
        )
        right_shoulder_elbow_vec = (
            right_shoulder_x - right_elbow_x,
            right_shoulder_y - right_elbow_y
        )
        right_wrist_elbow_vec = (
            right_wrist_x - right_elbow_x,
            right_wrist_y - right_elbow_y
        )

        # Calculate angle made between the left shoulder, left elbow, and left wrist
        left_angle = self.angle_between_vectors_in_rad(
            *left_shoulder_elbow_vec,
            *left_wrist_elbow_vec
        )
        # Calculate angle made between the right shoulder, right elbow, and right wrist
        right_angle = self.angle_between_vectors_in_rad(
            *right_shoulder_elbow_vec,
            *right_wrist_elbow_vec
        )
        if left_angle == self.ERROR_OUTPUT or right_angle == self.ERROR_OUTPUT:
            # Needs debugging
            self.logger.warning(
                &#39;Either one or both the calculated angles in are_arms_folded() has returned an error.&#39; +
                f&#39;\nAngle calculated between left shoulder to left elbow {left_shoulder_elbow_vec} &#39; +
                f&#39;and left wrist to left elbow {left_wrist_elbow_vec} is {left_angle} radians.&#39; +
                f&#39;\nAngle calculated between right shoulder to right elbow {right_shoulder_elbow_vec} &#39; +
                f&#39;and right wrist to right elbow {right_wrist_elbow_vec} is {right_angle} radians.&#39;
            )
            return False

        # Calculate distance from the left elbow to the left wrist
        left_dist = sqrt(
            (left_wrist_x - left_elbow_x) * (left_wrist_x - left_elbow_x) + \
            (left_wrist_y - left_elbow_y) * (left_wrist_y - left_elbow_y)
        )
        # Calculate distance from the right elbow to the right wrist
        right_dist = sqrt(
            (right_wrist_x - right_elbow_x) * (right_wrist_x - right_elbow_x) + \
            (right_wrist_y - right_elbow_y) * (right_wrist_y - right_elbow_y)
        )
        # Calculate distance between the two shoulders
        shoulder_dist = sqrt(
            (right_shoulder_x - left_shoulder_x) * (right_shoulder_x - left_shoulder_x) + \
            (right_shoulder_y - left_shoulder_y) * (right_shoulder_y - left_shoulder_y)
        )

        threshold = 2 * pi / 3  # 2/3pi rad or 120 deg
        # Check if left arm is folded
        left_folded = left_angle &lt; threshold and \
            right_shoulder_x &lt;= left_wrist_x &lt;= left_shoulder_x and \
            left_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
            left_dist * 2 &gt;= shoulder_dist
        # Check if right arm is folded
        right_folded = right_angle &lt; threshold and \
            right_shoulder_x &lt;= right_wrist_x &lt;= left_shoulder_x and \
            right_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
            right_dist * 2 &gt;= shoulder_dist
        # Check if both arms are folded
        return left_folded and right_folded

    def is_face_touched(
            self,
            left_elbow: Optional[Coord],
            right_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_wrist: Optional[Coord],
            nose: Optional[Coord],
            left_eye: Optional[Coord],
            right_eye: Optional[Coord],
            left_ear: Optional[Coord],
            right_ear: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the hands of the given pose is touching the face

        Parameters
        ----------
        left_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the left elbow
        right_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the right elbow
        left_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the left wrist
        right_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the right wrist
        nose : `Coord`, optional
            (`x`, `y`) coordinate of the nose
        left_eye : `Coord`, optional
            (`x`, `y`) coordinate of the left eye
        right_eye : `Coord`, optional
            (`x`, `y`) coordinate of the right eye
        left_ear : `Coord`, optional
            (`x`, `y`) coordinate of the left ear
        right_ear : `Coord`, optional
            (`x`, `y`) coordinate of the right ear

        Returns
        -------
        bool
            ``True`` if either hand is touching the face, ``False`` otherwise

        Notes
        -----
        A pose is considered to be touching the face if the following conditions are satisfied:

        - Any of the coordinates for the elbows or wrists are defined
        - Any of the coordinates for the nose, eyes, or ears are defined
        - The distance from the facial feature(s) to the arm feature(s) is sufficiently small
        &#34;&#34;&#34;

        # Define threshold for distance
        threshold = 100

        # Obtain coordinates of defined limb
        for limb_coordinate in [left_elbow, right_elbow, left_wrist, right_wrist]:
            if limb_coordinate is None:
                continue

            # Obtain coordinates of defined facial feature
            for face_coordinate in [nose, left_eye, right_eye, left_ear, right_ear]:
                if face_coordinate is None:
                    continue

                # Calculate distance between limb joint and facial feature joint
                limb_x, limb_y = limb_coordinate
                face_x, face_y = face_coordinate
                dist = sqrt(
                    (limb_x - face_x) * (limb_x - face_x) + \
                    (limb_y - face_y) * (limb_y - face_y)
                )

                # Check if limb is touching the face
                if dist &lt; threshold:
                    return True

        # No pair of coordinates exist that satisfy the distance threshold
        return False

    def is_leaning(
            self,
            left_shoulder: Optional[Coord],
            right_shoulder: Optional[Coord],
            left_hip: Optional[Coord],
            right_hip: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the given pose is leaning towards one side

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left shoulder
        right_shoulder : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right shoulder
        left_hip : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left hip
        right_hip : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right hip
        left_knee : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left knee
        right_knee : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right knee

        Returns
        -------
        bool
            ``True`` if the pose is leaning towards one side, ``False`` otherwise

        Notes
        -----
        The line from the shoulder to the hip intersects the hip line.

        A pose is considered leaning if the angle that the two lines make with each other
            falls outside a `15`-degree tolerance.
        &#34;&#34;&#34;

        # Check if keypoints are defined
        if left_shoulder is None or \
                left_hip is None or \
                right_shoulder is None or \
                right_hip is None:
            return False

        # Initialize buffer
        # Get left and right shoulder keypoints
        left_shoulder_x, left_shoulder_y = left_shoulder
        right_shoulder_x, right_shoulder_y = right_shoulder
        # Get left and right hip keypoints
        left_hip_x, left_hip_y = left_hip
        right_hip_x, right_hip_y = right_hip

        # Calculate the angle between left shoulder to left hip to left knee
        left_angle = self.angle_between_vectors_in_rad(
            left_shoulder_x - left_hip_x,
            left_shoulder_y - left_hip_y,
            right_hip_x - left_hip_x,
            right_hip_y - left_hip_y
        )
        # Calculate the angle between right shoulder to right hip to right knee
        right_angle = self.angle_between_vectors_in_rad(
            right_shoulder_x - right_hip_x,
            right_shoulder_y - right_hip_y,
            left_hip_x - right_hip_x,
            left_hip_y - right_hip_y
        )

        # Check if either side has crossed the threshold for leaning
        sway_threshold = 15 * pi / 180  # 15 deg
        return left_angle &lt; pi/2 - sway_threshold or \
            right_angle &lt; pi/2 - sway_threshold or \
            left_angle &gt; pi/2 + sway_threshold or \
            right_angle &gt; pi/2 + sway_threshold

    def run(
            self,
            inputs: Mapping[str, Any]
    ) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;Displays calculated PoseNet keypoints and relevant statistics onto the video feed

        Parameters
        ----------
        inputs : dict
            Input dictionary with keys &#34;img&#34;, &#34;bboxes&#34;, &#34;bbox_scores&#34;, &#34;keypoints&#34;, &#34;keypoint_scores&#34;

        Returns
        -------
        dict
            Empty dictionary

        Notes
        -----
        This function keeps track of the following statistics:

        - Total number of processed frames
        - Total number of frames where the pose had folded arms
        - Total number of frames where the pose was leaning
        - Total number of frames where the pose was touching face
        &#34;&#34;&#34;

        # Initialise constants
        error_msg = &#39;The input dictionary does not contain the {} key.&#39;
        frames_before_summary = 200

        # Check if required inputs are in pipeline
        if &#39;img&#39; not in inputs:
            # There must be an image to display
            # Otherwise, `self._display_text()` will raise an error
            self._logger.error(error_msg.format(&#34;&#39;img&#39;&#34;))
            return {}
        for key in (&#39;bboxes&#39;, &#39;bbox_scores&#39;, &#39;keypoints&#39;, &#39;keypoint_scores&#39;):
            if key not in inputs:
                # One or more metadata inputs are missing
                self._logger.warning(error_msg.format(f&#34;&#39;{key}&#39;&#34;))

        # Get required inputs from pipeline
        self._img = inputs[&#39;img&#39;]
        bboxes = inputs.get(&#39;bboxes&#39;, [])
        bbox_scores = inputs.get(&#39;bbox_scores&#39;, [])
        all_keypoints = inputs.get(&#39;keypoints&#39;, [])
        all_keypoint_scores = inputs.get(&#39;keypoint_scores&#39;, [])

        # Handle the detection of each person
        for bbox, bbox_score, keypoints, keypoint_scores in \
                zip(bboxes, bbox_scores, all_keypoints, all_keypoint_scores):

            # Store and display PoseNet keypoints
            keypoint_list = []
            for keypoint, keypoint_score in zip(keypoints, keypoint_scores):
                result = self._obtain_keypoint(keypoint.tolist(), keypoint_score)
                keypoint_list.append(result)
                if result is None:
                    continue
                x, y = result
                self._display_text(
                    x,
                    y,
                    f&#39;({x}, {y})&#39;,
                    self._WHITE,
                    font_scale=0.5,
                    font_thickness=1
                )

            # pylint: disable=pointless-string-statement
            &#34;&#34;&#34;
            # Store the keypoints in a temporary text file for further processing
            with open(&#39;test.txt&#39;, &#39;a&#39;) as tmp_file:
                tmp_file.write(f&#39;{keypoint_list}\n&#39;)
            &#34;&#34;&#34;

            # Determine if the pose violates any bad presentation poses
            arms_folded = self.are_arms_folded(
                keypoint_list[self.KP_LEFT_SHOULDER],
                keypoint_list[self.KP_LEFT_ELBOW],
                keypoint_list[self.KP_LEFT_WRIST],
                keypoint_list[self.KP_RIGHT_SHOULDER],
                keypoint_list[self.KP_RIGHT_ELBOW],
                keypoint_list[self.KP_RIGHT_WRIST]
            )
            face_touched = self.is_face_touched(
                keypoint_list[self.KP_LEFT_ELBOW],
                keypoint_list[self.KP_RIGHT_ELBOW],
                keypoint_list[self.KP_LEFT_WRIST],
                keypoint_list[self.KP_RIGHT_WRIST],
                keypoint_list[self.KP_NOSE],
                keypoint_list[self.KP_LEFT_EYE],
                keypoint_list[self.KP_RIGHT_EYE],
                keypoint_list[self.KP_LEFT_EAR],
                keypoint_list[self.KP_RIGHT_EAR]
            )
            is_leaning = self.is_leaning(
                keypoint_list[self.KP_LEFT_SHOULDER],
                keypoint_list[self.KP_RIGHT_SHOULDER],
                keypoint_list[self.KP_LEFT_HIP],
                keypoint_list[self.KP_RIGHT_HIP]
            )

            # Increment relevant counters
            self._arm_fold_count += arms_folded
            self._face_touch_count += face_touched
            self._leaning_count += is_leaning

            # Display the results on the image
            self._display_bbox_info(
                bbox,
                bbox_score,
                arms_folded=arms_folded,
                is_leaning=is_leaning,
                face_touched=face_touched
            )

        self._total_frame_count += 1

        # UI config
        line =   &#39;----------------------&#39;
        title =  &#39;  Current Statistics&#39;
        arms =  f&#39;  Arm Folding - {self._arm_fold_count / self._total_frame_count * 100:0.3f}%&#39;
        lean =  f&#39;      Leaning - {self._leaning_count / self._total_frame_count * 100:0.3f}%&#39;
        face =  f&#39;Touching Face - {self._face_touch_count / self._total_frame_count * 100:0.3f}%&#39;
        frame = f&#39;[ Frame Count : {self._total_frame_count} ]&#39;

        if self._total_frame_count % frames_before_summary == 0:
            self._logger.info(&#39;\n&#39;.join((&#39;\n&#39;, line, title, line, arms, lean, face, frame, &#39;\n&#39;)))

        self._display_text(50, 100, line, self._BLUE, font_scale=1)
        self._display_text(50, 120, title, self._BLUE, font_scale=1)
        self._display_text(50, 140, line, self._BLUE, font_scale=1)
        self._display_text(50, 160, arms, self._BLUE, font_scale=1)
        self._display_text(50, 190, lean, self._BLUE, font_scale=1)
        self._display_text(50, 220, face, self._BLUE, font_scale=1)
        self._display_text(50, 250, frame, self._BLUE, font_scale=1)

        return {}


if __name__ == &#39;__main__&#39;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>config:Â Optional[Mapping[str,Â Any]]Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom node to display PoseNet's skeletal keypoints and pose category statistics onto the video feed</p>
<p>Initialises the custom node class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Node custom configuration</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for instantiating the AbstractNode parent class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(AbstractNode):
    &#34;&#34;&#34;Custom node to display PoseNet&#39;s skeletal keypoints and pose category statistics onto the video feed&#34;&#34;&#34;

    # TODO write documentation for custom node class

    # Define colours for display purposes
    # Note: OpenCV loads file in BGR format
    _WHITE = (255, 255, 255)
    _YELLOW = (0, 255, 255)
    _BLUE = (255, 0, 0)

    # Define font properties for display purposes
    _FONT_FACE = cv2.FONT_HERSHEY_SIMPLEX  # pylint: disable=no-member
    _FONT_SCALE = 1
    _FONT_THICKNESS = 2

    # Define constants for PoseNet keypoint detection
    _THRESHOLD = 0.6
    # PoseNet&#39;s skeletal key points
    # https://discuss.tensorflow.org/uploads/default/original/2X/9/951fd6aaf5fec83500fe2e9891348416e13b66dd.png
    (
        KP_NOSE,
        KP_LEFT_EYE,
        KP_RIGHT_EYE,
        KP_LEFT_EAR,
        KP_RIGHT_EAR,
        KP_LEFT_SHOULDER,
        KP_RIGHT_SHOULDER,
        KP_LEFT_ELBOW,
        KP_RIGHT_ELBOW,
        KP_LEFT_WRIST,
        KP_RIGHT_WRIST,
        KP_LEFT_HIP,
        KP_RIGHT_HIP,
        KP_LEFT_KNEE,
        KP_RIGHT_KNEE,
        KP_LEFT_FOOT,
        KP_RIGHT_FOOT
    ) = range(17)

    def __init__(
            self,
            config: Optional[Mapping[str, Any]] = None,
            **kwargs
    ) -&gt; None:
        &#34;&#34;&#34;Initialises the custom node class

        Parameters
        ----------
        config : dict, optional
            Node custom configuration

        Other Parameters
        ----------------
        **kwargs
            Keyword arguments for instantiating the AbstractNode parent class
        &#34;&#34;&#34;

        super().__init__(config, node_path=__name__, **kwargs)  # type: ignore
        self._logger = logging.getLogger(__name__)

        # Define variables used for tracking
        self._img = None
        self._arm_fold_count = self._leaning_count = self._face_touch_count = self._total_frame_count = 0

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Height of the displayed image, specified in pixels

        Returns
        -------
        int
            Height of the displayed image, specified in pixels.

            Returns ``ERROR_OUTPUT`` instead if the image is undefined.
        &#34;&#34;&#34;

        return self.ERROR_OUTPUT if self._img is None else self._img.shape[0]

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Width of the displayed image, specified in pixels

        Returns
        -------
        int
            Width of the displayed image, specified in pixels.

            Returns ``ERROR_OUTPUT`` instead if the image is undefined.
        &#34;&#34;&#34;

        return self.ERROR_OUTPUT if self._img is None else self._img.shape[1]

    @property
    def ERROR_OUTPUT(self) -&gt; int:
        &#34;&#34;&#34;Defines the default output for encountered errors as `-1`

        Computational functions will return non-negative input.

        Returns
        -------
        int
            `-1`, the default output.
        &#34;&#34;&#34;

        return -1

    def _map_coord_onto_img(
            self,
            x: float,
            y: float
    ) -&gt; Coord:
        &#34;&#34;&#34;Maps relative coordinates onto the displayed image

        This function assumes that the displayed image has already been defined.

        Parameters
        ----------
        x : float
            Relative horizontal position of the coordinate; 0 &lt;= `x` &lt;= 1
        y : float
            Relative vertical position of the coordinate; 0 &lt;= `y` &lt;= 1

        Returns
        -------
        `Coord`
            Absolute coordinate (`x1`, `y1`) on the image; 0 &lt;= `x1` &lt;= `width` and 0 &lt;= `y1` &lt;= `height`.

            Returns ``(ERROR_OUTPUT, ERROR_OUTPUT)`` if the image has not been defined.
       &#34;&#34;&#34;

        # Check if image is defined
        if self.width == self.ERROR_OUTPUT or self.height == self.ERROR_OUTPUT:
            self.logger.error(&#39;_map_coord_onto_img() trying to access image but it has not been defined yet.&#39;)
            return self.ERROR_OUTPUT, self.ERROR_OUTPUT

        return round(x * self.width), round(y * self.height)

    def _obtain_keypoint(
            self,
            keypoint: Tuple[float, float],
            score: float
    ) -&gt; Optional[Coord]:
        &#34;&#34;&#34;Obtains a detected PoseNet keypoint if its confidence score meets or exceeds the threshold

        Parameters
        ----------
        keypoint : tuple of floats
            Relative coordinate (`x`, `y`) of the detected PoseNet keypoint;
                0 &lt;= `x` &lt;= 1 and 0 &lt;= `y` &lt;= 1
        score : float
            Confidence score of the detected PoseNet keypoint

        Returns
        -------
        `Coord`, optional
            Absolute coordinates of the detected PoseNet keypoint
                if its confidence score meets or exceeds the threshold confidence
        &#34;&#34;&#34;

        return None if score &lt; self._THRESHOLD else self._map_coord_onto_img(*keypoint)

    def _display_text(
        self,
        x: int,
        y: int,
        text: str,
        font_colour: Tuple[int, int, int],
        *,
        font_face: int = _FONT_FACE,
        font_scale: float = _FONT_SCALE,
        font_thickness: int = _FONT_THICKNESS
    ) -&gt; None:
        &#34;&#34;&#34;Displays text at a specified coordinate on top of the displayed image

        Parameters
        ----------
        x : int
            x-coordinate to display the text at
        y : int
            y-coordinate to display the text at
        text : str
            Text to display
        font_colour : tuple of ints
            Colour of the text to display, specified in BGR format

        Other Parameters
        ----------------
        font_face : int, default=`_FONT_FACE`
            Font type of the text to display.

            Limited to a subset of Hershey Fonts as
                [supported by OpenCV](https://stackoverflow.com/questions/371910008/load-truetype-font-to-opencv).
        font_scale : float
            Relative size of the text to display
        font_thickness : int
            Relative thickness of the text to display
        &#34;&#34;&#34;

        # Check if image is defined
        if self._img is None:
            self.logger.error(&#39;_display_text() trying to access image but it has not been defined yet.&#39;)
            return

        cv2.putText(  # pylint: disable=no-member
            img=self._img,  # type: ignore
            text=text,
            org=(x, y),
            fontFace=font_face,
            fontScale=font_scale,
            color=font_colour,
            thickness=font_thickness
        )

    def _display_bbox_info(
            self,
            bbox: Tuple[int, int, int, int],
            score: float,
            *,
            arms_folded: bool = False,
            is_leaning: bool = False,
            face_touched: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Displays the information associated with the given bounding box

        Parameters
        ----------
        bbox : tuple of ints
            Bounding box, represented by its top-left (`x1`, `y1`) and bottom-right (`x2`, `y2`) coordinates.

            The parameter `bbox` is specified in the format (`x1`, `y1`, `x2`, `y2`);
                0 &lt;= `x1` &lt;= `x2` &lt;= `width` and 0 &lt;= `y1` &lt;= `y2` &lt;= `height`
        score : float
            Confidence score of the bounding box
        arms_folded : bool, default=False
            ``True`` if the person is detected to have folded their arms, ``False`` otherwise
        is_leaning : bool, default=False
            ``True``if the person is detected to be leaning to one side, ``False`` otherwise
        face_touched : bool, default=False
            ``True`` if the person is detected to be touching their face, ``False`` otherwise

        Notes
        -----
        All information will be displayed in the bottom-left corner (`x1`, `y2`) of the bounding box.

        This information includes the following:

        - Confidence score of the bounding box
        - Whether the arms are folded
        - Whether the person is leaning too much to one side
        - Whether the person is touching his/her face
        &#34;&#34;&#34;

        # Initialise constants
        num_lines = 3  # default number of &#39;lines&#39; above the bottom-left coordinate
        line_height = round(30 * self._FONT_SCALE)  # height of each &#39;line&#39; in pixels; 30 is arbitrary

        # Obtain bottom-left coordinate of bounding box
        x1, y1, x2, y2 = bbox
        x, _ = self._map_coord_onto_img(x1, y1)
        _, y = self._map_coord_onto_img(x2, y2)

        # Display information
        self._display_text(x, y - num_lines * line_height, f&#39;BBox {score:0.2f}&#39;, self._WHITE)
        if arms_folded:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Arms Folded&#39;, self._BLUE)
        if is_leaning:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Leaning&#39;, self._BLUE)
        if face_touched:
            num_lines += 1
            self._display_text(x, y - num_lines * line_height, &#39;Touching Face&#39;, self._BLUE)

    def angle_between_vectors_in_rad(
            self,
            x1: int,
            y1: int,
            x2: int,
            y2: int
    ) -&gt; float:
        &#34;&#34;&#34;Obtains the (smaller) angle between two non-zero vectors in radians

        The angle \\( \\Theta \\) is computed via the cosine rule (see the Notes section).

        Parameters
        ----------
        x1 : int
            The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the x-axis
        y1 : int
            The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the y-axis
        x2 : int
            The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the x-axis
        y2 : int
            The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the y-axis

        Returns
        -------
        float
            The (smaller) angle \\( \\Theta \\) between
                \\( \\overrightarrow{ V_{1} } \\) and
                \\( \\overrightarrow{ V_{2} } \\).

            Returns ``ERROR_OUTPUT`` instead if:

            - Either one or both of
                \\( \\overrightarrow{ V_{1} } = \\overrightarrow{0} \\) and
                \\( \\overrightarrow{ V_{2} } = \\overrightarrow{0} \\)
            - \\( \\cos \\Theta \\notin [-1, 1] \\)

        Notes
        -----
        The cosine of the (smaller) angle between two vectors
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} x_{1} \\\\ y_{1} \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} x_{2} \\\\ y_{2} \\end{pmatrix} \\)
        is calculated by:

        $$
        \\cos \\Theta
            = \\frac { \\overrightarrow{ V_{1} } \\cdot \\overrightarrow{ V_{2} } }
                    {\\left\\| \\overrightarrow{V_{1}} \\right\\| \\left\\| \\overrightarrow{V_{2}} \\right\\|}
            = \\frac {x_{1}x_{2} + y_{1}y_{2}}
                    {\\sqrt {{x_{1}}^2 + {y_{1}}^2} \\sqrt {{x_{2}}^2 + {y_{2}}^2}}
            ,\\ 0 \\le \\Theta \\le \\pi
        $$

        Hence, the angle \\( \\Theta \\) between
            \\( \\overrightarrow{ V_{1} } \\) and
            \\( \\overrightarrow{ V_{2} } \\)
        can be calculated by taking the inverse cosine of the result.

        Examples
        --------
        &gt;&gt;&gt; node = Node()

        The angle between two orthogonal vectors is \\( \\frac {\\pi} {2} \\).

        &gt;&gt;&gt; v1 = (0, 1)
        &gt;&gt;&gt; v2 = (1, 0)
        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v2)
        1.5707963267948966
        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v2, *v1)
        1.5707963267948966

        The angle between two parallel vectors is `0`.

        &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v1)
        0.0
        &#34;&#34;&#34;

        # Check for zero vectors
        if x1 == y1 == 0 or x2 == y2 == 0:
            self.logger.error(
                f&#39;One or more zero vectors v1 = ({x1}, {y1}) and &#39; +
                f&#39;v2 = ({x2}, {y2}) were passed into angle_between_vectors_in_rad().&#39;
            )
            return self.ERROR_OUTPUT

        # Compute the cosine value
        dot_prod = x1 * x2 + y1 * y2
        v1_magnitude = sqrt(x1 * x1 + y1 * y1)
        v2_magnitude = sqrt(x2 * x2 + y2 * y2)
        cos_value = dot_prod / (v1_magnitude * v2_magnitude)

        # Check if the cosine value is within acos domain of [-1, 1]
        if abs(cos_value) &gt; 1:
            self.logger.error(
                f&#39;angle_between_vectors_in_rad() obtained cosine value {cos_value} &#39; +
                &#39;that is not within acos domain [-1, 1]. &#39; +
                f&#39;v1 Â· v2 = {dot_prod}, ||v1|| = {v1_magnitude}, ||v2|| = {v2_magnitude}&#39;
            )
            return self.ERROR_OUTPUT

        return acos(cos_value)

    def are_arms_folded(
            self,
            left_shoulder: Optional[Coord],
            left_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_shoulder: Optional[Coord],
            right_elbow: Optional[Coord],
            right_wrist: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the arms of the given pose are folded

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            (`x`, `y`) coordinate of the left shoulder
        left_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the left elbow
        left_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the left wrist
        right_shoulder : `Coord`, optional
            (`x`, `y`) coordinate of the right shoulder
        right_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the right elbow
        right_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the right wrist

        Returns
        -------
        bool
            ``True`` if both arms are folded, ``False`` otherwise

        Notes
        -----
        The line from the shoulder to the elbow intersects the line from the wrist to the elbow at the elbow.

        An arm is considered folded if:

        - The angle that the two lines make with each other is less than `120` degrees
        - The x-coordinate of the wrist lies in between the x-coordinates of the shoulders
        - The y-coordinate of the wrist lies below the y-coordinate of either shoulder
        - The distance between the wrist and the elbow is at least half that between the shoulders
        &#34;&#34;&#34;

        # Check if keypoints are defined
        if left_shoulder is None or \
                left_elbow is None or \
                left_wrist is None or \
                right_shoulder is None or \
                right_elbow is None or \
                right_wrist is None:
            return False

        # Obtain coordinates
        left_shoulder_x, left_shoulder_y = left_shoulder
        right_shoulder_x, right_shoulder_y = right_shoulder
        left_elbow_x, left_elbow_y = left_elbow
        right_elbow_x, right_elbow_y = right_elbow
        left_wrist_x, left_wrist_y = left_wrist
        right_wrist_x, right_wrist_y = right_wrist

        # Calculate relevant vectors
        left_shoulder_elbow_vec = (
            left_shoulder_x - left_elbow_x,
            left_shoulder_y - left_elbow_y
        )
        left_wrist_elbow_vec = (
            left_wrist_x - left_elbow_x,
            left_wrist_y - left_elbow_y
        )
        right_shoulder_elbow_vec = (
            right_shoulder_x - right_elbow_x,
            right_shoulder_y - right_elbow_y
        )
        right_wrist_elbow_vec = (
            right_wrist_x - right_elbow_x,
            right_wrist_y - right_elbow_y
        )

        # Calculate angle made between the left shoulder, left elbow, and left wrist
        left_angle = self.angle_between_vectors_in_rad(
            *left_shoulder_elbow_vec,
            *left_wrist_elbow_vec
        )
        # Calculate angle made between the right shoulder, right elbow, and right wrist
        right_angle = self.angle_between_vectors_in_rad(
            *right_shoulder_elbow_vec,
            *right_wrist_elbow_vec
        )
        if left_angle == self.ERROR_OUTPUT or right_angle == self.ERROR_OUTPUT:
            # Needs debugging
            self.logger.warning(
                &#39;Either one or both the calculated angles in are_arms_folded() has returned an error.&#39; +
                f&#39;\nAngle calculated between left shoulder to left elbow {left_shoulder_elbow_vec} &#39; +
                f&#39;and left wrist to left elbow {left_wrist_elbow_vec} is {left_angle} radians.&#39; +
                f&#39;\nAngle calculated between right shoulder to right elbow {right_shoulder_elbow_vec} &#39; +
                f&#39;and right wrist to right elbow {right_wrist_elbow_vec} is {right_angle} radians.&#39;
            )
            return False

        # Calculate distance from the left elbow to the left wrist
        left_dist = sqrt(
            (left_wrist_x - left_elbow_x) * (left_wrist_x - left_elbow_x) + \
            (left_wrist_y - left_elbow_y) * (left_wrist_y - left_elbow_y)
        )
        # Calculate distance from the right elbow to the right wrist
        right_dist = sqrt(
            (right_wrist_x - right_elbow_x) * (right_wrist_x - right_elbow_x) + \
            (right_wrist_y - right_elbow_y) * (right_wrist_y - right_elbow_y)
        )
        # Calculate distance between the two shoulders
        shoulder_dist = sqrt(
            (right_shoulder_x - left_shoulder_x) * (right_shoulder_x - left_shoulder_x) + \
            (right_shoulder_y - left_shoulder_y) * (right_shoulder_y - left_shoulder_y)
        )

        threshold = 2 * pi / 3  # 2/3pi rad or 120 deg
        # Check if left arm is folded
        left_folded = left_angle &lt; threshold and \
            right_shoulder_x &lt;= left_wrist_x &lt;= left_shoulder_x and \
            left_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
            left_dist * 2 &gt;= shoulder_dist
        # Check if right arm is folded
        right_folded = right_angle &lt; threshold and \
            right_shoulder_x &lt;= right_wrist_x &lt;= left_shoulder_x and \
            right_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
            right_dist * 2 &gt;= shoulder_dist
        # Check if both arms are folded
        return left_folded and right_folded

    def is_face_touched(
            self,
            left_elbow: Optional[Coord],
            right_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_wrist: Optional[Coord],
            nose: Optional[Coord],
            left_eye: Optional[Coord],
            right_eye: Optional[Coord],
            left_ear: Optional[Coord],
            right_ear: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the hands of the given pose is touching the face

        Parameters
        ----------
        left_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the left elbow
        right_elbow : `Coord`, optional
            (`x`, `y`) coordinate of the right elbow
        left_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the left wrist
        right_wrist : `Coord`, optional
            (`x`, `y`) coordinate of the right wrist
        nose : `Coord`, optional
            (`x`, `y`) coordinate of the nose
        left_eye : `Coord`, optional
            (`x`, `y`) coordinate of the left eye
        right_eye : `Coord`, optional
            (`x`, `y`) coordinate of the right eye
        left_ear : `Coord`, optional
            (`x`, `y`) coordinate of the left ear
        right_ear : `Coord`, optional
            (`x`, `y`) coordinate of the right ear

        Returns
        -------
        bool
            ``True`` if either hand is touching the face, ``False`` otherwise

        Notes
        -----
        A pose is considered to be touching the face if the following conditions are satisfied:

        - Any of the coordinates for the elbows or wrists are defined
        - Any of the coordinates for the nose, eyes, or ears are defined
        - The distance from the facial feature(s) to the arm feature(s) is sufficiently small
        &#34;&#34;&#34;

        # Define threshold for distance
        threshold = 100

        # Obtain coordinates of defined limb
        for limb_coordinate in [left_elbow, right_elbow, left_wrist, right_wrist]:
            if limb_coordinate is None:
                continue

            # Obtain coordinates of defined facial feature
            for face_coordinate in [nose, left_eye, right_eye, left_ear, right_ear]:
                if face_coordinate is None:
                    continue

                # Calculate distance between limb joint and facial feature joint
                limb_x, limb_y = limb_coordinate
                face_x, face_y = face_coordinate
                dist = sqrt(
                    (limb_x - face_x) * (limb_x - face_x) + \
                    (limb_y - face_y) * (limb_y - face_y)
                )

                # Check if limb is touching the face
                if dist &lt; threshold:
                    return True

        # No pair of coordinates exist that satisfy the distance threshold
        return False

    def is_leaning(
            self,
            left_shoulder: Optional[Coord],
            right_shoulder: Optional[Coord],
            left_hip: Optional[Coord],
            right_hip: Optional[Coord]
    ) -&gt; bool:
        &#34;&#34;&#34;Determines if the given pose is leaning towards one side

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left shoulder
        right_shoulder : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right shoulder
        left_hip : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left hip
        right_hip : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right hip
        left_knee : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the left knee
        right_knee : `Coord`, optional
            Tuple containing the `x` and `y` coordinates of the right knee

        Returns
        -------
        bool
            ``True`` if the pose is leaning towards one side, ``False`` otherwise

        Notes
        -----
        The line from the shoulder to the hip intersects the hip line.

        A pose is considered leaning if the angle that the two lines make with each other
            falls outside a `15`-degree tolerance.
        &#34;&#34;&#34;

        # Check if keypoints are defined
        if left_shoulder is None or \
                left_hip is None or \
                right_shoulder is None or \
                right_hip is None:
            return False

        # Initialize buffer
        # Get left and right shoulder keypoints
        left_shoulder_x, left_shoulder_y = left_shoulder
        right_shoulder_x, right_shoulder_y = right_shoulder
        # Get left and right hip keypoints
        left_hip_x, left_hip_y = left_hip
        right_hip_x, right_hip_y = right_hip

        # Calculate the angle between left shoulder to left hip to left knee
        left_angle = self.angle_between_vectors_in_rad(
            left_shoulder_x - left_hip_x,
            left_shoulder_y - left_hip_y,
            right_hip_x - left_hip_x,
            right_hip_y - left_hip_y
        )
        # Calculate the angle between right shoulder to right hip to right knee
        right_angle = self.angle_between_vectors_in_rad(
            right_shoulder_x - right_hip_x,
            right_shoulder_y - right_hip_y,
            left_hip_x - right_hip_x,
            left_hip_y - right_hip_y
        )

        # Check if either side has crossed the threshold for leaning
        sway_threshold = 15 * pi / 180  # 15 deg
        return left_angle &lt; pi/2 - sway_threshold or \
            right_angle &lt; pi/2 - sway_threshold or \
            left_angle &gt; pi/2 + sway_threshold or \
            right_angle &gt; pi/2 + sway_threshold

    def run(
            self,
            inputs: Mapping[str, Any]
    ) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;Displays calculated PoseNet keypoints and relevant statistics onto the video feed

        Parameters
        ----------
        inputs : dict
            Input dictionary with keys &#34;img&#34;, &#34;bboxes&#34;, &#34;bbox_scores&#34;, &#34;keypoints&#34;, &#34;keypoint_scores&#34;

        Returns
        -------
        dict
            Empty dictionary

        Notes
        -----
        This function keeps track of the following statistics:

        - Total number of processed frames
        - Total number of frames where the pose had folded arms
        - Total number of frames where the pose was leaning
        - Total number of frames where the pose was touching face
        &#34;&#34;&#34;

        # Initialise constants
        error_msg = &#39;The input dictionary does not contain the {} key.&#39;
        frames_before_summary = 200

        # Check if required inputs are in pipeline
        if &#39;img&#39; not in inputs:
            # There must be an image to display
            # Otherwise, `self._display_text()` will raise an error
            self._logger.error(error_msg.format(&#34;&#39;img&#39;&#34;))
            return {}
        for key in (&#39;bboxes&#39;, &#39;bbox_scores&#39;, &#39;keypoints&#39;, &#39;keypoint_scores&#39;):
            if key not in inputs:
                # One or more metadata inputs are missing
                self._logger.warning(error_msg.format(f&#34;&#39;{key}&#39;&#34;))

        # Get required inputs from pipeline
        self._img = inputs[&#39;img&#39;]
        bboxes = inputs.get(&#39;bboxes&#39;, [])
        bbox_scores = inputs.get(&#39;bbox_scores&#39;, [])
        all_keypoints = inputs.get(&#39;keypoints&#39;, [])
        all_keypoint_scores = inputs.get(&#39;keypoint_scores&#39;, [])

        # Handle the detection of each person
        for bbox, bbox_score, keypoints, keypoint_scores in \
                zip(bboxes, bbox_scores, all_keypoints, all_keypoint_scores):

            # Store and display PoseNet keypoints
            keypoint_list = []
            for keypoint, keypoint_score in zip(keypoints, keypoint_scores):
                result = self._obtain_keypoint(keypoint.tolist(), keypoint_score)
                keypoint_list.append(result)
                if result is None:
                    continue
                x, y = result
                self._display_text(
                    x,
                    y,
                    f&#39;({x}, {y})&#39;,
                    self._WHITE,
                    font_scale=0.5,
                    font_thickness=1
                )

            # pylint: disable=pointless-string-statement
            &#34;&#34;&#34;
            # Store the keypoints in a temporary text file for further processing
            with open(&#39;test.txt&#39;, &#39;a&#39;) as tmp_file:
                tmp_file.write(f&#39;{keypoint_list}\n&#39;)
            &#34;&#34;&#34;

            # Determine if the pose violates any bad presentation poses
            arms_folded = self.are_arms_folded(
                keypoint_list[self.KP_LEFT_SHOULDER],
                keypoint_list[self.KP_LEFT_ELBOW],
                keypoint_list[self.KP_LEFT_WRIST],
                keypoint_list[self.KP_RIGHT_SHOULDER],
                keypoint_list[self.KP_RIGHT_ELBOW],
                keypoint_list[self.KP_RIGHT_WRIST]
            )
            face_touched = self.is_face_touched(
                keypoint_list[self.KP_LEFT_ELBOW],
                keypoint_list[self.KP_RIGHT_ELBOW],
                keypoint_list[self.KP_LEFT_WRIST],
                keypoint_list[self.KP_RIGHT_WRIST],
                keypoint_list[self.KP_NOSE],
                keypoint_list[self.KP_LEFT_EYE],
                keypoint_list[self.KP_RIGHT_EYE],
                keypoint_list[self.KP_LEFT_EAR],
                keypoint_list[self.KP_RIGHT_EAR]
            )
            is_leaning = self.is_leaning(
                keypoint_list[self.KP_LEFT_SHOULDER],
                keypoint_list[self.KP_RIGHT_SHOULDER],
                keypoint_list[self.KP_LEFT_HIP],
                keypoint_list[self.KP_RIGHT_HIP]
            )

            # Increment relevant counters
            self._arm_fold_count += arms_folded
            self._face_touch_count += face_touched
            self._leaning_count += is_leaning

            # Display the results on the image
            self._display_bbox_info(
                bbox,
                bbox_score,
                arms_folded=arms_folded,
                is_leaning=is_leaning,
                face_touched=face_touched
            )

        self._total_frame_count += 1

        # UI config
        line =   &#39;----------------------&#39;
        title =  &#39;  Current Statistics&#39;
        arms =  f&#39;  Arm Folding - {self._arm_fold_count / self._total_frame_count * 100:0.3f}%&#39;
        lean =  f&#39;      Leaning - {self._leaning_count / self._total_frame_count * 100:0.3f}%&#39;
        face =  f&#39;Touching Face - {self._face_touch_count / self._total_frame_count * 100:0.3f}%&#39;
        frame = f&#39;[ Frame Count : {self._total_frame_count} ]&#39;

        if self._total_frame_count % frames_before_summary == 0:
            self._logger.info(&#39;\n&#39;.join((&#39;\n&#39;, line, title, line, arms, lean, face, frame, &#39;\n&#39;)))

        self._display_text(50, 100, line, self._BLUE, font_scale=1)
        self._display_text(50, 120, title, self._BLUE, font_scale=1)
        self._display_text(50, 140, line, self._BLUE, font_scale=1)
        self._display_text(50, 160, arms, self._BLUE, font_scale=1)
        self._display_text(50, 190, lean, self._BLUE, font_scale=1)
        self._display_text(50, 220, face, self._BLUE, font_scale=1)
        self._display_text(50, 250, frame, self._BLUE, font_scale=1)

        return {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>peekingduck.pipeline.nodes.abstract_node.AbstractNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EAR"><code class="name">var <span class="ident">KP_LEFT_EAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_ELBOW"><code class="name">var <span class="ident">KP_LEFT_ELBOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EYE"><code class="name">var <span class="ident">KP_LEFT_EYE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_FOOT"><code class="name">var <span class="ident">KP_LEFT_FOOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_HIP"><code class="name">var <span class="ident">KP_LEFT_HIP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_KNEE"><code class="name">var <span class="ident">KP_LEFT_KNEE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_SHOULDER"><code class="name">var <span class="ident">KP_LEFT_SHOULDER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_WRIST"><code class="name">var <span class="ident">KP_LEFT_WRIST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_NOSE"><code class="name">var <span class="ident">KP_NOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EAR"><code class="name">var <span class="ident">KP_RIGHT_EAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_ELBOW"><code class="name">var <span class="ident">KP_RIGHT_ELBOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EYE"><code class="name">var <span class="ident">KP_RIGHT_EYE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_FOOT"><code class="name">var <span class="ident">KP_RIGHT_FOOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_HIP"><code class="name">var <span class="ident">KP_RIGHT_HIP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_KNEE"><code class="name">var <span class="ident">KP_RIGHT_KNEE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_SHOULDER"><code class="name">var <span class="ident">KP_RIGHT_SHOULDER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_WRIST"><code class="name">var <span class="ident">KP_RIGHT_WRIST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.ERROR_OUTPUT"><code class="name">var <span class="ident">ERROR_OUTPUT</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Defines the default output for encountered errors as <code>-1</code></p>
<p>Computational functions will return non-negative input.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd><code>-1</code>, the default output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ERROR_OUTPUT(self) -&gt; int:
    &#34;&#34;&#34;Defines the default output for encountered errors as `-1`

    Computational functions will return non-negative input.

    Returns
    -------
    int
        `-1`, the default output.
    &#34;&#34;&#34;

    return -1</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.height"><code class="name">var <span class="ident">height</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Height of the displayed image, specified in pixels</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>
<p>Height of the displayed image, specified in pixels.</p>
<p>Returns <code>ERROR_OUTPUT</code> instead if the image is undefined.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    &#34;&#34;&#34;Height of the displayed image, specified in pixels

    Returns
    -------
    int
        Height of the displayed image, specified in pixels.

        Returns ``ERROR_OUTPUT`` instead if the image is undefined.
    &#34;&#34;&#34;

    return self.ERROR_OUTPUT if self._img is None else self._img.shape[0]</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.width"><code class="name">var <span class="ident">width</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Width of the displayed image, specified in pixels</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>
<p>Width of the displayed image, specified in pixels.</p>
<p>Returns <code>ERROR_OUTPUT</code> instead if the image is undefined.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;Width of the displayed image, specified in pixels

    Returns
    -------
    int
        Width of the displayed image, specified in pixels.

        Returns ``ERROR_OUTPUT`` instead if the image is undefined.
    &#34;&#34;&#34;

    return self.ERROR_OUTPUT if self._img is None else self._img.shape[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.angle_between_vectors_in_rad"><code class="name flex">
<span>def <span class="ident">angle_between_vectors_in_rad</span></span>(<span>self, x1:Â int, y1:Â int, x2:Â int, y2:Â int) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Obtains the (smaller) angle between two non-zero vectors in radians</p>
<p>The angle <span><span class="MathJax_Preview"> \Theta </span><script type="math/tex"> \Theta </script></span> is computed via the cosine rule (see the Notes section).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of vector <span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } </span><script type="math/tex"> \overrightarrow{ V_{1} } </script></span> in the x-axis</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of vector <span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } </span><script type="math/tex"> \overrightarrow{ V_{1} } </script></span> in the y-axis</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of vector <span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } </span><script type="math/tex"> \overrightarrow{ V_{2} } </script></span> in the x-axis</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of vector <span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } </span><script type="math/tex"> \overrightarrow{ V_{2} } </script></span> in the y-axis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>
<p>The (smaller) angle <span><span class="MathJax_Preview"> \Theta </span><script type="math/tex"> \Theta </script></span> between
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } </span><script type="math/tex"> \overrightarrow{ V_{1} } </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } </span><script type="math/tex"> \overrightarrow{ V_{2} } </script></span>.</p>
<p>Returns <code>ERROR_OUTPUT</code> instead if:</p>
<ul>
<li>Either one or both of
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } = \overrightarrow{0} </span><script type="math/tex"> \overrightarrow{ V_{1} } = \overrightarrow{0} </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } = \overrightarrow{0} </span><script type="math/tex"> \overrightarrow{ V_{2} } = \overrightarrow{0} </script></span></li>
<li><span><span class="MathJax_Preview"> \cos \Theta \notin [-1, 1] </span><script type="math/tex"> \cos \Theta \notin [-1, 1] </script></span></li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The cosine of the (smaller) angle between two vectors
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } = \begin{pmatrix} x_{1} \\ y_{1} \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{1} } = \begin{pmatrix} x_{1} \\ y_{1} \end{pmatrix} </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } = \begin{pmatrix} x_{2} \\ y_{2} \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{2} } = \begin{pmatrix} x_{2} \\ y_{2} \end{pmatrix} </script></span>
is calculated by:</p>
<p><span><span class="MathJax_Preview">
\cos \Theta
= \frac { \overrightarrow{ V_{1} } \cdot \overrightarrow{ V_{2} } }
{\left\| \overrightarrow{V_{1}} \right\| \left\| \overrightarrow{V_{2}} \right\|}
= \frac {x_{1}x_{2} + y_{1}y_{2}}
{\sqrt {{x_{1}}^2 + {y_{1}}^2} \sqrt {{x_{2}}^2 + {y_{2}}^2}}
,\ 0 \le \Theta \le \pi
</span><script type="math/tex; mode=display">
\cos \Theta
= \frac { \overrightarrow{ V_{1} } \cdot \overrightarrow{ V_{2} } }
{\left\| \overrightarrow{V_{1}} \right\| \left\| \overrightarrow{V_{2}} \right\|}
= \frac {x_{1}x_{2} + y_{1}y_{2}}
{\sqrt {{x_{1}}^2 + {y_{1}}^2} \sqrt {{x_{2}}^2 + {y_{2}}^2}}
,\ 0 \le \Theta \le \pi
</script></span></p>
<p>Hence, the angle <span><span class="MathJax_Preview"> \Theta </span><script type="math/tex"> \Theta </script></span> between
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } </span><script type="math/tex"> \overrightarrow{ V_{1} } </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } </span><script type="math/tex"> \overrightarrow{ V_{2} } </script></span>
can be calculated by taking the inverse cosine of the result.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = Node()
</code></pre>
<p>The angle between two orthogonal vectors is <span><span class="MathJax_Preview"> \frac {\pi} {2} </span><script type="math/tex"> \frac {\pi} {2} </script></span>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; v1 = (0, 1)
&gt;&gt;&gt; v2 = (1, 0)
&gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v2)
1.5707963267948966
&gt;&gt;&gt; node.angle_between_vectors_in_rad(*v2, *v1)
1.5707963267948966
</code></pre>
<p>The angle between two parallel vectors is <code>0</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v1)
0.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_between_vectors_in_rad(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int
) -&gt; float:
    &#34;&#34;&#34;Obtains the (smaller) angle between two non-zero vectors in radians

    The angle \\( \\Theta \\) is computed via the cosine rule (see the Notes section).

    Parameters
    ----------
    x1 : int
        The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the x-axis
    y1 : int
        The magnitude of vector \\( \\overrightarrow{ V_{1} } \\) in the y-axis
    x2 : int
        The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the x-axis
    y2 : int
        The magnitude of vector \\( \\overrightarrow{ V_{2} } \\) in the y-axis

    Returns
    -------
    float
        The (smaller) angle \\( \\Theta \\) between
            \\( \\overrightarrow{ V_{1} } \\) and
            \\( \\overrightarrow{ V_{2} } \\).

        Returns ``ERROR_OUTPUT`` instead if:

        - Either one or both of
            \\( \\overrightarrow{ V_{1} } = \\overrightarrow{0} \\) and
            \\( \\overrightarrow{ V_{2} } = \\overrightarrow{0} \\)
        - \\( \\cos \\Theta \\notin [-1, 1] \\)

    Notes
    -----
    The cosine of the (smaller) angle between two vectors
        \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} x_{1} \\\\ y_{1} \\end{pmatrix} \\) and
        \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} x_{2} \\\\ y_{2} \\end{pmatrix} \\)
    is calculated by:

    $$
    \\cos \\Theta
        = \\frac { \\overrightarrow{ V_{1} } \\cdot \\overrightarrow{ V_{2} } }
                {\\left\\| \\overrightarrow{V_{1}} \\right\\| \\left\\| \\overrightarrow{V_{2}} \\right\\|}
        = \\frac {x_{1}x_{2} + y_{1}y_{2}}
                {\\sqrt {{x_{1}}^2 + {y_{1}}^2} \\sqrt {{x_{2}}^2 + {y_{2}}^2}}
        ,\\ 0 \\le \\Theta \\le \\pi
    $$

    Hence, the angle \\( \\Theta \\) between
        \\( \\overrightarrow{ V_{1} } \\) and
        \\( \\overrightarrow{ V_{2} } \\)
    can be calculated by taking the inverse cosine of the result.

    Examples
    --------
    &gt;&gt;&gt; node = Node()

    The angle between two orthogonal vectors is \\( \\frac {\\pi} {2} \\).

    &gt;&gt;&gt; v1 = (0, 1)
    &gt;&gt;&gt; v2 = (1, 0)
    &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v2)
    1.5707963267948966
    &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v2, *v1)
    1.5707963267948966

    The angle between two parallel vectors is `0`.

    &gt;&gt;&gt; node.angle_between_vectors_in_rad(*v1, *v1)
    0.0
    &#34;&#34;&#34;

    # Check for zero vectors
    if x1 == y1 == 0 or x2 == y2 == 0:
        self.logger.error(
            f&#39;One or more zero vectors v1 = ({x1}, {y1}) and &#39; +
            f&#39;v2 = ({x2}, {y2}) were passed into angle_between_vectors_in_rad().&#39;
        )
        return self.ERROR_OUTPUT

    # Compute the cosine value
    dot_prod = x1 * x2 + y1 * y2
    v1_magnitude = sqrt(x1 * x1 + y1 * y1)
    v2_magnitude = sqrt(x2 * x2 + y2 * y2)
    cos_value = dot_prod / (v1_magnitude * v2_magnitude)

    # Check if the cosine value is within acos domain of [-1, 1]
    if abs(cos_value) &gt; 1:
        self.logger.error(
            f&#39;angle_between_vectors_in_rad() obtained cosine value {cos_value} &#39; +
            &#39;that is not within acos domain [-1, 1]. &#39; +
            f&#39;v1 Â· v2 = {dot_prod}, ||v1|| = {v1_magnitude}, ||v2|| = {v2_magnitude}&#39;
        )
        return self.ERROR_OUTPUT

    return acos(cos_value)</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.are_arms_folded"><code class="name flex">
<span>def <span class="ident">are_arms_folded</span></span>(<span>self, left_shoulder:Â Optional[Tuple[int,Â int]], left_elbow:Â Optional[Tuple[int,Â int]], left_wrist:Â Optional[Tuple[int,Â int]], right_shoulder:Â Optional[Tuple[int,Â int]], right_elbow:Â Optional[Tuple[int,Â int]], right_wrist:Â Optional[Tuple[int,Â int]]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the arms of the given pose are folded</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left shoulder</dd>
<dt><strong><code>left_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left elbow</dd>
<dt><strong><code>left_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left wrist</dd>
<dt><strong><code>right_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right shoulder</dd>
<dt><strong><code>right_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right elbow</dd>
<dt><strong><code>right_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right wrist</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if both arms are folded, <code>False</code> otherwise</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The line from the shoulder to the elbow intersects the line from the wrist to the elbow at the elbow.</p>
<p>An arm is considered folded if:</p>
<ul>
<li>The angle that the two lines make with each other is less than <code>120</code> degrees</li>
<li>The x-coordinate of the wrist lies in between the x-coordinates of the shoulders</li>
<li>The y-coordinate of the wrist lies below the y-coordinate of either shoulder</li>
<li>The distance between the wrist and the elbow is at least half that between the shoulders</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def are_arms_folded(
        self,
        left_shoulder: Optional[Coord],
        left_elbow: Optional[Coord],
        left_wrist: Optional[Coord],
        right_shoulder: Optional[Coord],
        right_elbow: Optional[Coord],
        right_wrist: Optional[Coord]
) -&gt; bool:
    &#34;&#34;&#34;Determines if the arms of the given pose are folded

    Parameters
    ----------
    left_shoulder : `Coord`, optional
        (`x`, `y`) coordinate of the left shoulder
    left_elbow : `Coord`, optional
        (`x`, `y`) coordinate of the left elbow
    left_wrist : `Coord`, optional
        (`x`, `y`) coordinate of the left wrist
    right_shoulder : `Coord`, optional
        (`x`, `y`) coordinate of the right shoulder
    right_elbow : `Coord`, optional
        (`x`, `y`) coordinate of the right elbow
    right_wrist : `Coord`, optional
        (`x`, `y`) coordinate of the right wrist

    Returns
    -------
    bool
        ``True`` if both arms are folded, ``False`` otherwise

    Notes
    -----
    The line from the shoulder to the elbow intersects the line from the wrist to the elbow at the elbow.

    An arm is considered folded if:

    - The angle that the two lines make with each other is less than `120` degrees
    - The x-coordinate of the wrist lies in between the x-coordinates of the shoulders
    - The y-coordinate of the wrist lies below the y-coordinate of either shoulder
    - The distance between the wrist and the elbow is at least half that between the shoulders
    &#34;&#34;&#34;

    # Check if keypoints are defined
    if left_shoulder is None or \
            left_elbow is None or \
            left_wrist is None or \
            right_shoulder is None or \
            right_elbow is None or \
            right_wrist is None:
        return False

    # Obtain coordinates
    left_shoulder_x, left_shoulder_y = left_shoulder
    right_shoulder_x, right_shoulder_y = right_shoulder
    left_elbow_x, left_elbow_y = left_elbow
    right_elbow_x, right_elbow_y = right_elbow
    left_wrist_x, left_wrist_y = left_wrist
    right_wrist_x, right_wrist_y = right_wrist

    # Calculate relevant vectors
    left_shoulder_elbow_vec = (
        left_shoulder_x - left_elbow_x,
        left_shoulder_y - left_elbow_y
    )
    left_wrist_elbow_vec = (
        left_wrist_x - left_elbow_x,
        left_wrist_y - left_elbow_y
    )
    right_shoulder_elbow_vec = (
        right_shoulder_x - right_elbow_x,
        right_shoulder_y - right_elbow_y
    )
    right_wrist_elbow_vec = (
        right_wrist_x - right_elbow_x,
        right_wrist_y - right_elbow_y
    )

    # Calculate angle made between the left shoulder, left elbow, and left wrist
    left_angle = self.angle_between_vectors_in_rad(
        *left_shoulder_elbow_vec,
        *left_wrist_elbow_vec
    )
    # Calculate angle made between the right shoulder, right elbow, and right wrist
    right_angle = self.angle_between_vectors_in_rad(
        *right_shoulder_elbow_vec,
        *right_wrist_elbow_vec
    )
    if left_angle == self.ERROR_OUTPUT or right_angle == self.ERROR_OUTPUT:
        # Needs debugging
        self.logger.warning(
            &#39;Either one or both the calculated angles in are_arms_folded() has returned an error.&#39; +
            f&#39;\nAngle calculated between left shoulder to left elbow {left_shoulder_elbow_vec} &#39; +
            f&#39;and left wrist to left elbow {left_wrist_elbow_vec} is {left_angle} radians.&#39; +
            f&#39;\nAngle calculated between right shoulder to right elbow {right_shoulder_elbow_vec} &#39; +
            f&#39;and right wrist to right elbow {right_wrist_elbow_vec} is {right_angle} radians.&#39;
        )
        return False

    # Calculate distance from the left elbow to the left wrist
    left_dist = sqrt(
        (left_wrist_x - left_elbow_x) * (left_wrist_x - left_elbow_x) + \
        (left_wrist_y - left_elbow_y) * (left_wrist_y - left_elbow_y)
    )
    # Calculate distance from the right elbow to the right wrist
    right_dist = sqrt(
        (right_wrist_x - right_elbow_x) * (right_wrist_x - right_elbow_x) + \
        (right_wrist_y - right_elbow_y) * (right_wrist_y - right_elbow_y)
    )
    # Calculate distance between the two shoulders
    shoulder_dist = sqrt(
        (right_shoulder_x - left_shoulder_x) * (right_shoulder_x - left_shoulder_x) + \
        (right_shoulder_y - left_shoulder_y) * (right_shoulder_y - left_shoulder_y)
    )

    threshold = 2 * pi / 3  # 2/3pi rad or 120 deg
    # Check if left arm is folded
    left_folded = left_angle &lt; threshold and \
        right_shoulder_x &lt;= left_wrist_x &lt;= left_shoulder_x and \
        left_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
        left_dist * 2 &gt;= shoulder_dist
    # Check if right arm is folded
    right_folded = right_angle &lt; threshold and \
        right_shoulder_x &lt;= right_wrist_x &lt;= left_shoulder_x and \
        right_wrist_y &gt; min(left_shoulder_y, right_shoulder_y) and \
        right_dist * 2 &gt;= shoulder_dist
    # Check if both arms are folded
    return left_folded and right_folded</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_face_touched"><code class="name flex">
<span>def <span class="ident">is_face_touched</span></span>(<span>self, left_elbow:Â Optional[Tuple[int,Â int]], right_elbow:Â Optional[Tuple[int,Â int]], left_wrist:Â Optional[Tuple[int,Â int]], right_wrist:Â Optional[Tuple[int,Â int]], nose:Â Optional[Tuple[int,Â int]], left_eye:Â Optional[Tuple[int,Â int]], right_eye:Â Optional[Tuple[int,Â int]], left_ear:Â Optional[Tuple[int,Â int]], right_ear:Â Optional[Tuple[int,Â int]]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the hands of the given pose is touching the face</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left elbow</dd>
<dt><strong><code>right_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right elbow</dd>
<dt><strong><code>left_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left wrist</dd>
<dt><strong><code>right_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right wrist</dd>
<dt><strong><code>nose</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the nose</dd>
<dt><strong><code>left_eye</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left eye</dd>
<dt><strong><code>right_eye</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right eye</dd>
<dt><strong><code>left_ear</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the left ear</dd>
<dt><strong><code>right_ear</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>(<code>x</code>, <code>y</code>) coordinate of the right ear</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if either hand is touching the face, <code>False</code> otherwise</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A pose is considered to be touching the face if the following conditions are satisfied:</p>
<ul>
<li>Any of the coordinates for the elbows or wrists are defined</li>
<li>Any of the coordinates for the nose, eyes, or ears are defined</li>
<li>The distance from the facial feature(s) to the arm feature(s) is sufficiently small</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_face_touched(
        self,
        left_elbow: Optional[Coord],
        right_elbow: Optional[Coord],
        left_wrist: Optional[Coord],
        right_wrist: Optional[Coord],
        nose: Optional[Coord],
        left_eye: Optional[Coord],
        right_eye: Optional[Coord],
        left_ear: Optional[Coord],
        right_ear: Optional[Coord]
) -&gt; bool:
    &#34;&#34;&#34;Determines if the hands of the given pose is touching the face

    Parameters
    ----------
    left_elbow : `Coord`, optional
        (`x`, `y`) coordinate of the left elbow
    right_elbow : `Coord`, optional
        (`x`, `y`) coordinate of the right elbow
    left_wrist : `Coord`, optional
        (`x`, `y`) coordinate of the left wrist
    right_wrist : `Coord`, optional
        (`x`, `y`) coordinate of the right wrist
    nose : `Coord`, optional
        (`x`, `y`) coordinate of the nose
    left_eye : `Coord`, optional
        (`x`, `y`) coordinate of the left eye
    right_eye : `Coord`, optional
        (`x`, `y`) coordinate of the right eye
    left_ear : `Coord`, optional
        (`x`, `y`) coordinate of the left ear
    right_ear : `Coord`, optional
        (`x`, `y`) coordinate of the right ear

    Returns
    -------
    bool
        ``True`` if either hand is touching the face, ``False`` otherwise

    Notes
    -----
    A pose is considered to be touching the face if the following conditions are satisfied:

    - Any of the coordinates for the elbows or wrists are defined
    - Any of the coordinates for the nose, eyes, or ears are defined
    - The distance from the facial feature(s) to the arm feature(s) is sufficiently small
    &#34;&#34;&#34;

    # Define threshold for distance
    threshold = 100

    # Obtain coordinates of defined limb
    for limb_coordinate in [left_elbow, right_elbow, left_wrist, right_wrist]:
        if limb_coordinate is None:
            continue

        # Obtain coordinates of defined facial feature
        for face_coordinate in [nose, left_eye, right_eye, left_ear, right_ear]:
            if face_coordinate is None:
                continue

            # Calculate distance between limb joint and facial feature joint
            limb_x, limb_y = limb_coordinate
            face_x, face_y = face_coordinate
            dist = sqrt(
                (limb_x - face_x) * (limb_x - face_x) + \
                (limb_y - face_y) * (limb_y - face_y)
            )

            # Check if limb is touching the face
            if dist &lt; threshold:
                return True

    # No pair of coordinates exist that satisfy the distance threshold
    return False</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_leaning"><code class="name flex">
<span>def <span class="ident">is_leaning</span></span>(<span>self, left_shoulder:Â Optional[Tuple[int,Â int]], right_shoulder:Â Optional[Tuple[int,Â int]], left_hip:Â Optional[Tuple[int,Â int]], right_hip:Â Optional[Tuple[int,Â int]]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given pose is leaning towards one side</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the left shoulder</dd>
<dt><strong><code>right_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the right shoulder</dd>
<dt><strong><code>left_hip</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the left hip</dd>
<dt><strong><code>right_hip</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the right hip</dd>
<dt><strong><code>left_knee</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the left knee</dd>
<dt><strong><code>right_knee</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>Tuple containing the <code>x</code> and <code>y</code> coordinates of the right knee</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the pose is leaning towards one side, <code>False</code> otherwise</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The line from the shoulder to the hip intersects the hip line.</p>
<p>A pose is considered leaning if the angle that the two lines make with each other
falls outside a <code>15</code>-degree tolerance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_leaning(
        self,
        left_shoulder: Optional[Coord],
        right_shoulder: Optional[Coord],
        left_hip: Optional[Coord],
        right_hip: Optional[Coord]
) -&gt; bool:
    &#34;&#34;&#34;Determines if the given pose is leaning towards one side

    Parameters
    ----------
    left_shoulder : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the left shoulder
    right_shoulder : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the right shoulder
    left_hip : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the left hip
    right_hip : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the right hip
    left_knee : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the left knee
    right_knee : `Coord`, optional
        Tuple containing the `x` and `y` coordinates of the right knee

    Returns
    -------
    bool
        ``True`` if the pose is leaning towards one side, ``False`` otherwise

    Notes
    -----
    The line from the shoulder to the hip intersects the hip line.

    A pose is considered leaning if the angle that the two lines make with each other
        falls outside a `15`-degree tolerance.
    &#34;&#34;&#34;

    # Check if keypoints are defined
    if left_shoulder is None or \
            left_hip is None or \
            right_shoulder is None or \
            right_hip is None:
        return False

    # Initialize buffer
    # Get left and right shoulder keypoints
    left_shoulder_x, left_shoulder_y = left_shoulder
    right_shoulder_x, right_shoulder_y = right_shoulder
    # Get left and right hip keypoints
    left_hip_x, left_hip_y = left_hip
    right_hip_x, right_hip_y = right_hip

    # Calculate the angle between left shoulder to left hip to left knee
    left_angle = self.angle_between_vectors_in_rad(
        left_shoulder_x - left_hip_x,
        left_shoulder_y - left_hip_y,
        right_hip_x - left_hip_x,
        right_hip_y - left_hip_y
    )
    # Calculate the angle between right shoulder to right hip to right knee
    right_angle = self.angle_between_vectors_in_rad(
        right_shoulder_x - right_hip_x,
        right_shoulder_y - right_hip_y,
        left_hip_x - right_hip_x,
        left_hip_y - right_hip_y
    )

    # Check if either side has crossed the threshold for leaning
    sway_threshold = 15 * pi / 180  # 15 deg
    return left_angle &lt; pi/2 - sway_threshold or \
        right_angle &lt; pi/2 - sway_threshold or \
        left_angle &gt; pi/2 + sway_threshold or \
        right_angle &gt; pi/2 + sway_threshold</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, inputs:Â Mapping[str,Â Any]) â€‘>Â Mapping[str,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Displays calculated PoseNet keypoints and relevant statistics onto the video feed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inputs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary with keys "img", "bboxes", "bbox_scores", "keypoints", "keypoint_scores"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Empty dictionary</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function keeps track of the following statistics:</p>
<ul>
<li>Total number of processed frames</li>
<li>Total number of frames where the pose had folded arms</li>
<li>Total number of frames where the pose was leaning</li>
<li>Total number of frames where the pose was touching face</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
        self,
        inputs: Mapping[str, Any]
) -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;Displays calculated PoseNet keypoints and relevant statistics onto the video feed

    Parameters
    ----------
    inputs : dict
        Input dictionary with keys &#34;img&#34;, &#34;bboxes&#34;, &#34;bbox_scores&#34;, &#34;keypoints&#34;, &#34;keypoint_scores&#34;

    Returns
    -------
    dict
        Empty dictionary

    Notes
    -----
    This function keeps track of the following statistics:

    - Total number of processed frames
    - Total number of frames where the pose had folded arms
    - Total number of frames where the pose was leaning
    - Total number of frames where the pose was touching face
    &#34;&#34;&#34;

    # Initialise constants
    error_msg = &#39;The input dictionary does not contain the {} key.&#39;
    frames_before_summary = 200

    # Check if required inputs are in pipeline
    if &#39;img&#39; not in inputs:
        # There must be an image to display
        # Otherwise, `self._display_text()` will raise an error
        self._logger.error(error_msg.format(&#34;&#39;img&#39;&#34;))
        return {}
    for key in (&#39;bboxes&#39;, &#39;bbox_scores&#39;, &#39;keypoints&#39;, &#39;keypoint_scores&#39;):
        if key not in inputs:
            # One or more metadata inputs are missing
            self._logger.warning(error_msg.format(f&#34;&#39;{key}&#39;&#34;))

    # Get required inputs from pipeline
    self._img = inputs[&#39;img&#39;]
    bboxes = inputs.get(&#39;bboxes&#39;, [])
    bbox_scores = inputs.get(&#39;bbox_scores&#39;, [])
    all_keypoints = inputs.get(&#39;keypoints&#39;, [])
    all_keypoint_scores = inputs.get(&#39;keypoint_scores&#39;, [])

    # Handle the detection of each person
    for bbox, bbox_score, keypoints, keypoint_scores in \
            zip(bboxes, bbox_scores, all_keypoints, all_keypoint_scores):

        # Store and display PoseNet keypoints
        keypoint_list = []
        for keypoint, keypoint_score in zip(keypoints, keypoint_scores):
            result = self._obtain_keypoint(keypoint.tolist(), keypoint_score)
            keypoint_list.append(result)
            if result is None:
                continue
            x, y = result
            self._display_text(
                x,
                y,
                f&#39;({x}, {y})&#39;,
                self._WHITE,
                font_scale=0.5,
                font_thickness=1
            )

        # pylint: disable=pointless-string-statement
        &#34;&#34;&#34;
        # Store the keypoints in a temporary text file for further processing
        with open(&#39;test.txt&#39;, &#39;a&#39;) as tmp_file:
            tmp_file.write(f&#39;{keypoint_list}\n&#39;)
        &#34;&#34;&#34;

        # Determine if the pose violates any bad presentation poses
        arms_folded = self.are_arms_folded(
            keypoint_list[self.KP_LEFT_SHOULDER],
            keypoint_list[self.KP_LEFT_ELBOW],
            keypoint_list[self.KP_LEFT_WRIST],
            keypoint_list[self.KP_RIGHT_SHOULDER],
            keypoint_list[self.KP_RIGHT_ELBOW],
            keypoint_list[self.KP_RIGHT_WRIST]
        )
        face_touched = self.is_face_touched(
            keypoint_list[self.KP_LEFT_ELBOW],
            keypoint_list[self.KP_RIGHT_ELBOW],
            keypoint_list[self.KP_LEFT_WRIST],
            keypoint_list[self.KP_RIGHT_WRIST],
            keypoint_list[self.KP_NOSE],
            keypoint_list[self.KP_LEFT_EYE],
            keypoint_list[self.KP_RIGHT_EYE],
            keypoint_list[self.KP_LEFT_EAR],
            keypoint_list[self.KP_RIGHT_EAR]
        )
        is_leaning = self.is_leaning(
            keypoint_list[self.KP_LEFT_SHOULDER],
            keypoint_list[self.KP_RIGHT_SHOULDER],
            keypoint_list[self.KP_LEFT_HIP],
            keypoint_list[self.KP_RIGHT_HIP]
        )

        # Increment relevant counters
        self._arm_fold_count += arms_folded
        self._face_touch_count += face_touched
        self._leaning_count += is_leaning

        # Display the results on the image
        self._display_bbox_info(
            bbox,
            bbox_score,
            arms_folded=arms_folded,
            is_leaning=is_leaning,
            face_touched=face_touched
        )

    self._total_frame_count += 1

    # UI config
    line =   &#39;----------------------&#39;
    title =  &#39;  Current Statistics&#39;
    arms =  f&#39;  Arm Folding - {self._arm_fold_count / self._total_frame_count * 100:0.3f}%&#39;
    lean =  f&#39;      Leaning - {self._leaning_count / self._total_frame_count * 100:0.3f}%&#39;
    face =  f&#39;Touching Face - {self._face_touch_count / self._total_frame_count * 100:0.3f}%&#39;
    frame = f&#39;[ Frame Count : {self._total_frame_count} ]&#39;

    if self._total_frame_count % frames_before_summary == 0:
        self._logger.info(&#39;\n&#39;.join((&#39;\n&#39;, line, title, line, arms, lean, face, frame, &#39;\n&#39;)))

    self._display_text(50, 100, line, self._BLUE, font_scale=1)
    self._display_text(50, 120, title, self._BLUE, font_scale=1)
    self._display_text(50, 140, line, self._BLUE, font_scale=1)
    self._display_text(50, 160, arms, self._BLUE, font_scale=1)
    self._display_text(50, 190, lean, self._BLUE, font_scale=1)
    self._display_text(50, 220, face, self._BLUE, font_scale=1)
    self._display_text(50, 250, frame, self._BLUE, font_scale=1)

    return {}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#usage">Usage</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble" href="index.html">SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.ERROR_OUTPUT" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.ERROR_OUTPUT">ERROR_OUTPUT</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EAR" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EAR">KP_LEFT_EAR</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_ELBOW" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_ELBOW">KP_LEFT_ELBOW</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EYE" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_EYE">KP_LEFT_EYE</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_FOOT" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_FOOT">KP_LEFT_FOOT</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_HIP" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_HIP">KP_LEFT_HIP</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_KNEE" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_KNEE">KP_LEFT_KNEE</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_SHOULDER" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_SHOULDER">KP_LEFT_SHOULDER</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_WRIST" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_LEFT_WRIST">KP_LEFT_WRIST</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_NOSE" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_NOSE">KP_NOSE</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EAR" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EAR">KP_RIGHT_EAR</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_ELBOW" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_ELBOW">KP_RIGHT_ELBOW</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EYE" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_EYE">KP_RIGHT_EYE</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_FOOT" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_FOOT">KP_RIGHT_FOOT</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_HIP" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_HIP">KP_RIGHT_HIP</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_KNEE" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_KNEE">KP_RIGHT_KNEE</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_SHOULDER" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_SHOULDER">KP_RIGHT_SHOULDER</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_WRIST" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.KP_RIGHT_WRIST">KP_RIGHT_WRIST</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.angle_between_vectors_in_rad" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.angle_between_vectors_in_rad">angle_between_vectors_in_rad</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.are_arms_folded" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.are_arms_folded">are_arms_folded</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.height" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.height">height</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_face_touched" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_face_touched">is_face_touched</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_leaning" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.is_leaning">is_leaning</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.run" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.run">run</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.width" href="#SpeakEase.analysis_video_pipeline.src.custom_nodes.dabble.movement.Node.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>