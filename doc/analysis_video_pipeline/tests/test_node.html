<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>SpeakEase.analysis_video_pipeline.tests.test_node API documentation</title>
<meta name="description" content="Docstring for the test_node.py module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SpeakEase.analysis_video_pipeline.tests.test_node</code></h1>
</header>
<section id="section-intro">
<p>Docstring for the test_node.py module</p>
<p>This module implements unit tests for the custom node class.</p>
<h2 id="usage">Usage</h2>
<p>From the terminal, navigate to the directory where this file is located.</p>
<p>Proceed to execute either of the following commands:</p>
<pre><code>python -m unittest [-v] test_node.py
python -m unittest discover
</code></pre>
<p><em>Note that -v is an optional flag to increase the verbosity of the unit test outputs.</em></p>
<p>For more information, refer to the
<a href="https://docs.python.org/3/library/unittest.html#test-discovery">official unit testing documentation</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Docstring for the test_node.py module

This module implements unit tests for the custom node class.

Usage
-----
From the terminal, navigate to the directory where this file is located.

Proceed to execute either of the following commands:

```
python -m unittest [-v] test_node.py
python -m unittest discover
```

_Note that -v is an optional flag to increase the verbosity of the unit test outputs._

For more information, refer to the
[official unit testing documentation](https://docs.python.org/3/library/unittest.html#test-discovery).
&#34;&#34;&#34;

# pylint: disable=import-error, invalid-name, too-many-lines

from itertools import chain, combinations, product
from math import pi
from typing import Optional, Tuple
import unittest
from yaml import safe_load

from analysis_video_pipeline.src.custom_nodes.dabble.movement import Node

from analysis_video_pipeline.tests.visualise import \
    ARE_ARMS_FOLDED_NEGATIVE_CASES_OUTSTRETCHED_ARMS, \
    ARE_ARMS_FOLDED_NEGATIVE_CASES_TOUCHING_FACE, \
    ARE_ARMS_FOLDED_POSITIVE_CASES_HALF_CROSS, \
    ARE_ARMS_FOLDED_POSITIVE_CASES_FULL_CROSS, \
    IS_LEANING_NEGATIVE_CASES, \
    IS_LEANING_POSITIVE_CASES, \
    IS_TOUCHING_FACE_POSITIVE_CASES_ALL_DEFINED


Coord = Tuple[int, int]  # Type-hinting alias for coordinates


class TestNode(unittest.TestCase):
    # TODO class documentation

    # Define decimal point precision
    _DECIMAL_PRECISION = 6

    def setUp(self) -&gt; None:
        &#34;&#34;&#34;Initialises the Node object used for unit testing&#34;&#34;&#34;

        # Initialise YML filepath
        filepath = &#39;analysis_video_pipeline/src/custom_nodes/configs/dabble/movement.yml&#39;

        # Obtain Node instance
        with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as config_file:
            config = safe_load(config_file)
            self.node = Node(config=config)

    &#34;&#34;&#34;Test cases for angle_between_vectors_in_rad()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_angle_between_vectors_in_rad(
            self,
            v1: Coord,
            v2: Coord,
            output: float,
            expected: float,
            test: str,
            *,
            precision: int = _DECIMAL_PRECISION
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `angle_between_vectors_in_rad()`

        Parameters
        ----------
        v1 : `Coord`
            The first vector (`x`, `y`) parameter passed into the function
        v2 : `Coord`
            The second vector (`x`, `y`) parameter passed into the function
        output : float
            The obtained output from the function
        expected : float
            The expected output of the function
        test : str
            The type of unit test performed
        precision : int, default=`_DECIMAL_PRECISION`
            The expected decimal precision of the outputs

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: angle_between_vectors_in_rad()\n\
                 Test Type: {test}\n\
                Parameters: v1 = {v1}, v2 = {v2}\n\
                 Precision: {precision}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_angle_between_vectors_in_rad_zero(self) -&gt; None:
        &#34;&#34;&#34;Checks if passing a zero vector into the function results in an error

        The function is expected to output ``Node.ERROR_OUTPUT``.
        &#34;&#34;&#34;

        # Initialise zero vector zero and non-zero vector vec
        zero = (0, 0)
        vec = (0, 1)

        # Obtain results
        r1 = self.node.angle_between_vectors_in_rad(*zero, *vec)
        r2 = self.node.angle_between_vectors_in_rad(*vec, *zero)
        r3 = self.node.angle_between_vectors_in_rad(*zero, *zero)

        # Perform assertion checks
        self.assertEqual(
            r1,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                zero,
                vec,
                r1,
                self.node.ERROR_OUTPUT,
                &#39;First Parameter is Zero Vector&#39;,
                precision=0
            )
        )
        self.assertEqual(
            r2,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                vec,
                zero,
                r2,
                self.node.ERROR_OUTPUT,
                &#39;Second Parameter is Zero Vector&#39;,
                precision=0
            )
        )
        self.assertEqual(
            r3,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                zero,
                zero,
                r3,
                self.node.ERROR_OUTPUT,
                &#39;Both Parameters are Zero Vectors&#39;,
                precision=0
            )
        )

    def test_angle_between_vectors_in_rad_associativity(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function is associative

        The order in which the vectors are passed into the function should not matter.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 3)
        v2 = (-2, 5)

        # Obtain results
        r1 = self.node.angle_between_vectors_in_rad(*v1, *v2)
        r2 = self.node.angle_between_vectors_in_rad(*v2, *v1)

        # Perform assertion checks
        self.assertAlmostEqual(
            r1,
            r2,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                r1,
                r2,
                &#39;Function Associativity&#39;
            )
        )

    def test_angle_between_vectors_in_rad_orthogonal(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two orthogonal non-zero vectors

        Two non-zero orthogonal vectors should make an angle of
            \\( \\frac {\\pi} {2} \\) radians between them.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2 that are orthogonal to each other
        v1 = (0, 1)
        v2 = (1, 0)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi / 2,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi / 2,
                &#39;Orthogonal Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_identical(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two identical non-zero vectors

        Two identical non-zero vectors should make an angle of `0` radians between them.
        &#34;&#34;&#34;

        # Initialise vector vec
        vec = (0, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*vec, *vec)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            0,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                vec,
                vec,
                res,
                0,
                &#39;Identical Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_opposite(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two non-zero vectors of equal magnitude but opposite direction

        Two non-zero vectors of equal magnitude but opposite direction
            should make an angle of \\( \\pi \\) radians between them.
        &#34;&#34;&#34;

        # Initialise opposite vectors v1 and v2
        v1 = (0, 1)
        v2 = (0, -1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi,
                &#39;Opposite Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_acute(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(1, 1)`

        Notes
        -----
        ```
          ^
        2 |
          |    (1, 1)
        1 |   x
          |
        0 ----x---------&gt;
               (1, 0)
          0   1   2   3
        ```

        The angle between
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\)
        should be \\( \\frac {\\pi} {4} \\) radians.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 0)
        v2 = (1, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi / 4,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi / 4,
                &#39;Acute Angle&#39;
            )
        )

    def test_angle_between_vectors_in_rad_obtuse(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(-1, 1)`

        Notes
        -----
        ```
                   ^
                   | 2
        (-1, 1)    |
               x   | 1
                   |
           ------------x---------&gt;
                        (1, 0)
           -2  -1  0   1   2   3
        ```

        The angle between
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\)
        should be \\( \\frac {3 \\pi} {4} \\) radians.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 0)
        v2 = (-1, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            3 * pi / 4,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                3 * pi / 4,
                &#39;Obtuse Angle&#39;
            )
        )

    &#34;&#34;&#34;Test cases for are_arms_folded()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_are_arms_folded(
            self,
            left_shoulder: Optional[Coord],
            left_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_shoulder: Optional[Coord],
            right_elbow: Optional[Coord],
            right_wrist: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `are_arms_folded()`

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            The left shoulder coordinate (`x`, `y`) passed into the function
        left_elbow : `Coord`, optional
            The left elbow coordinate (`x`, `y`) passed into the function
        left_wrist : `Coord`, optional
            The left wrist coordinate (`x`, `y`) passed into the function
        right_shoulder : `Coord`, optional
            The right shoulder coordinate (`x`, `y`) passed into the function
        right_elbow : `Coord`, optional
            The right elbow coordinate (`x`, `y`) passed into the function
        right_wrist : `Coord`, optional
            The right wrist coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: are_arms_folded()\n\
                 Test Type: {test}\n\
                Parameters: left_shouler = {left_shoulder}\n\
                            left_elbow = {left_elbow}\n\
                            left_wrist = {left_wrist}\n\
                            right_shoulder = {right_shoulder}\n\
                            right_elbow = {right_elbow}\n\
                            right_wrist = {right_wrist}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_are_arms_folded_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

        The function requires all coordinates to perform the check.
        &#34;&#34;&#34;

        # Initialise coordinates
        pose = [(i, i) for i in range(17)]
        required_coordinates = {
            self.node.KP_LEFT_SHOULDER,
            self.node.KP_LEFT_ELBOW,
            self.node.KP_LEFT_WRIST,
            self.node.KP_RIGHT_SHOULDER,
            self.node.KP_RIGHT_ELBOW,
            self.node.KP_RIGHT_WRIST
        }
        coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

        # Set one or more coordinates to None
        for i, selected_coordinates in enumerate(chain(
                *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
        )):
            left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_LEFT_SHOULDER]
            left_elbow = None if self.node.KP_LEFT_ELBOW in selected_coordinates else \
                coordinates[self.node.KP_LEFT_ELBOW]
            left_wrist = None if self.node.KP_LEFT_WRIST in selected_coordinates else \
                coordinates[self.node.KP_LEFT_WRIST]
            right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_SHOULDER]
            right_elbow = None if self.node.KP_RIGHT_ELBOW in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_ELBOW]
            right_wrist = None if self.node.KP_RIGHT_WRIST in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_WRIST]

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;One or more Missing Inputs (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_touching_face(self) -&gt; None:
        &#34;&#34;&#34;Checks that the arms are not considered folded if the pose is touching the face&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_TOUCHING_FACE):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;Touching Face instead of Folding Arms (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_outstretched_arms(self) -&gt; None:
        &#34;&#34;&#34;Check that outstretched arms are not considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_OUTSTRETCHED_ARMS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;Arms Outstretched (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_half_cross(self) -&gt; None:
        &#34;&#34;&#34;Checks that half-crossed arms are considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_HALF_CROSS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    True,
                    f&#39;Arms Half-Crossed (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_full_cross(self) -&gt; None:
        &#34;&#34;&#34;Checks that fully-crossed arms are considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_FULL_CROSS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    True,
                    f&#39;Arms Full-Crossed (Case {i + 1})&#39;
                )
            )

    &#34;&#34;&#34;Test cases for is_face_touched()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_is_face_touched(
            self,
            left_elbow: Optional[Coord],
            right_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_wrist: Optional[Coord],
            nose: Optional[Coord],
            left_eye: Optional[Coord],
            right_eye: Optional[Coord],
            left_ear: Optional[Coord],
            right_ear: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `is_face_touched()`

        Parameters
        ----------
        left_elbow : `Coord`, optional
            The left elbow coordinate (`x`, `y`) passed into the function
        right_elbow : `Coord`, optional
            The right elbow coordinate (`x`, `y`) passed into the function
        left_wrist : `Coord`, optional
            The left wrist coordinate (`x`, `y`) passed into the function
        right_wrist : `Coord`, optional
            The right wrist coordinate (`x`, `y`) passed into the function
        nose : `Coord`, optional
            The nose coordinate (`x`, `y`) passed into the function
        left_eye : `Coord`, optional
            The left eye coordinate (`x`, `y`) passed into the function
        right_eye : `Coord`, optional
            The right eye coordinate (`x`, `y`) passed into the function
        left_ear : `Coord`, optional
            The left ear coordinate (`x`, `y`) passed into the function
        right_ear : `Coord`, optional
            The right ear coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: is_face_touched()\n\
                 Test Type: {test}\n\
                Parameters: left_elbow = {left_elbow}\n\
                            right_elbow = {right_elbow}\n\
                            left_wrist = {left_wrist}\n\
                            right_wrist = {right_wrist}\n\
                            nose = {nose}\n\
                            left_eye = {left_eye}\n\
                            right_eye = {right_eye}\n\
                            left_ear = {left_ear}\n\
                            right_ear = {right_ear}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_is_face_touched_all_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that undefined poses return ``False``&#34;&#34;&#34;

        # Obtain the resut
        res = self.node.is_face_touched(
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_face_touched(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                res,
                False,
                &#39;Touching Face All Missing&#39;
            )
        )

    def test_is_face_touched_negative_some_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses are undefined if all of the keypoints in a required set are undefined

        The function requires that at least one keypoint in each set of keypoints is defined.
        &#34;&#34;&#34;

        # Select coordinates to define
        for i, (limb_coordinate, face_coordinate) in enumerate(((None, (0, 0)), ((0, 0), None))):

            # Initialise coordinates
            left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
            nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    False,
                    f&#39;Touching Face Negative Some Defined (Case {i + 1})&#39;
                )
            )

    def test_is_face_touched_negative_all_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses that do not meet the requirement are considered not touching face&#34;&#34;&#34;

        # Initialise fake coordinates for limb features and facial features
        limb_coordinate = (250, 250)
        face_coordinate = (0, 0)

        # Initialise coordinates
        left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
        nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

        # Obtain the result
        res = self.node.is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear,
                res,
                False,
                &#39;Touching Face Negative All Defined&#39;
            )
        )

    def test_is_face_touched_positive_some_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses are considered as touching face even with some undefined keypoints

        The function is expected to check every possible pair of points
            for one that meets the requirement for touching face.
        &#34;&#34;&#34;

        # Initialise fake coordinates for limb features and facial features
        limb_coordinate = (25, 25)
        face_coordinate = (0, 0)

        # Select coordinates to define
        for case, (i, j) in enumerate(product(range(4), range(4, 9))):

            # Initialise coordinate list
            # Define limb coordinate at index i and facial coordinate at index j
            coordinates = [None] * 9
            coordinates[i] = limb_coordinate  # type: ignore
            coordinates[j] = face_coordinate  # type: ignore

            # Initialise specific coordinates
            left_elbow, \
                right_elbow, \
                left_wrist, \
                right_wrist, \
                nose, \
                left_eye, \
                right_eye, \
                left_ear, \
                right_ear, = coordinates

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    True,
                    f&#39;Touching Face Positive Some Defined (Case {case + 1})&#39;
                )
            )

    def test_is_face_touched_all_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses where the face is touched is considered as touching face&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_TOUCHING_FACE_POSITIVE_CASES_ALL_DEFINED):

            # Initialise coordinates
            left_elbow, \
                right_elbow, \
                left_wrist, \
                right_wrist, \
                nose, \
                left_eye, \
                right_eye, \
                left_ear, \
                right_ear, = coordinates

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    True,
                    f&#39;Touching Face All Defined (Case {i + 1})&#39;
                )
            )

    &#34;&#34;&#34;Test cases for is_leaning()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_is_leaning(
            self,
            left_shoulder: Optional[Coord],
            right_shoulder: Optional[Coord],
            left_hip: Optional[Coord],
            right_hip: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `is_leaning()`

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            The left shoulder coordinate (`x`, `y`) passed into the function
        right_shoulder : `Coord`, optional
            The right shoulder coordinate (`x`, `y`) passed into the function
        left_hip : `Coord`, optional
            The left hip coordinate (`x`, `y`) passed into the function
        right_hip : `Coord`, optional
            The right hip coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: is_leaning()\n\
                 Test Type: {test}\n\
                Parameters: left_shouler = {left_shoulder}\n\
                            right_shoulder = {right_shoulder}\n\
                            left_hip = {left_hip}\n\
                            right_hip = {right_hip}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_is_leaning_folded_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

        The function requires all coordinates to perform the check.
        &#34;&#34;&#34;

        # Initialise coordinates
        pose = [(i, i) for i in range(17)]
        required_coordinates = {
            self.node.KP_LEFT_SHOULDER,
            self.node.KP_RIGHT_SHOULDER,
            self.node.KP_LEFT_HIP,
            self.node.KP_RIGHT_HIP
        }
        coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

        # Set one or more coordinates to None
        for i, selected_coordinates in enumerate(chain(
                *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
        )):
            left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_LEFT_SHOULDER]
            right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_SHOULDER]
            left_hip = None if self.node.KP_LEFT_HIP in selected_coordinates else \
                coordinates[self.node.KP_LEFT_HIP]
            right_hip = None if self.node.KP_RIGHT_HIP in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_HIP]

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    False,
                    f&#39;One or more Missing Inputs (Case {i + 1})&#39;
                )
            )

    def test_is_leaning_negative(self) -&gt; None:
        &#34;&#34;&#34;Checks that non-leaning poses are considered not leaning&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_LEANING_NEGATIVE_CASES):

            # Initialise coordinates
            left_shoulder, \
                right_shoulder, \
                left_hip, \
                right_hip = coordinates

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    False,
                    f&#39;Non-Leaning Pose (Case {i + 1})&#39;
                )
            )

    def test_is_leaning_positive(self) -&gt; None:
        &#34;&#34;&#34;Checks that true leaning poses are considered leaning&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_LEANING_POSITIVE_CASES):

            # Initialise coordinates
            left_shoulder, \
                right_shoulder, \
                left_hip, \
                right_hip = coordinates

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    True,
                    f&#39;Leaning Pose (Case {i + 1})&#39;
                )
            )


if __name__ == &#39;__main__&#39;:
    unittest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode"><code class="flex name class">
<span>class <span class="ident">TestNode</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestNode(unittest.TestCase):
    # TODO class documentation

    # Define decimal point precision
    _DECIMAL_PRECISION = 6

    def setUp(self) -&gt; None:
        &#34;&#34;&#34;Initialises the Node object used for unit testing&#34;&#34;&#34;

        # Initialise YML filepath
        filepath = &#39;analysis_video_pipeline/src/custom_nodes/configs/dabble/movement.yml&#39;

        # Obtain Node instance
        with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as config_file:
            config = safe_load(config_file)
            self.node = Node(config=config)

    &#34;&#34;&#34;Test cases for angle_between_vectors_in_rad()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_angle_between_vectors_in_rad(
            self,
            v1: Coord,
            v2: Coord,
            output: float,
            expected: float,
            test: str,
            *,
            precision: int = _DECIMAL_PRECISION
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `angle_between_vectors_in_rad()`

        Parameters
        ----------
        v1 : `Coord`
            The first vector (`x`, `y`) parameter passed into the function
        v2 : `Coord`
            The second vector (`x`, `y`) parameter passed into the function
        output : float
            The obtained output from the function
        expected : float
            The expected output of the function
        test : str
            The type of unit test performed
        precision : int, default=`_DECIMAL_PRECISION`
            The expected decimal precision of the outputs

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: angle_between_vectors_in_rad()\n\
                 Test Type: {test}\n\
                Parameters: v1 = {v1}, v2 = {v2}\n\
                 Precision: {precision}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_angle_between_vectors_in_rad_zero(self) -&gt; None:
        &#34;&#34;&#34;Checks if passing a zero vector into the function results in an error

        The function is expected to output ``Node.ERROR_OUTPUT``.
        &#34;&#34;&#34;

        # Initialise zero vector zero and non-zero vector vec
        zero = (0, 0)
        vec = (0, 1)

        # Obtain results
        r1 = self.node.angle_between_vectors_in_rad(*zero, *vec)
        r2 = self.node.angle_between_vectors_in_rad(*vec, *zero)
        r3 = self.node.angle_between_vectors_in_rad(*zero, *zero)

        # Perform assertion checks
        self.assertEqual(
            r1,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                zero,
                vec,
                r1,
                self.node.ERROR_OUTPUT,
                &#39;First Parameter is Zero Vector&#39;,
                precision=0
            )
        )
        self.assertEqual(
            r2,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                vec,
                zero,
                r2,
                self.node.ERROR_OUTPUT,
                &#39;Second Parameter is Zero Vector&#39;,
                precision=0
            )
        )
        self.assertEqual(
            r3,
            self.node.ERROR_OUTPUT,
            msg=self.error_msg_angle_between_vectors_in_rad(
                zero,
                zero,
                r3,
                self.node.ERROR_OUTPUT,
                &#39;Both Parameters are Zero Vectors&#39;,
                precision=0
            )
        )

    def test_angle_between_vectors_in_rad_associativity(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function is associative

        The order in which the vectors are passed into the function should not matter.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 3)
        v2 = (-2, 5)

        # Obtain results
        r1 = self.node.angle_between_vectors_in_rad(*v1, *v2)
        r2 = self.node.angle_between_vectors_in_rad(*v2, *v1)

        # Perform assertion checks
        self.assertAlmostEqual(
            r1,
            r2,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                r1,
                r2,
                &#39;Function Associativity&#39;
            )
        )

    def test_angle_between_vectors_in_rad_orthogonal(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two orthogonal non-zero vectors

        Two non-zero orthogonal vectors should make an angle of
            \\( \\frac {\\pi} {2} \\) radians between them.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2 that are orthogonal to each other
        v1 = (0, 1)
        v2 = (1, 0)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi / 2,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi / 2,
                &#39;Orthogonal Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_identical(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two identical non-zero vectors

        Two identical non-zero vectors should make an angle of `0` radians between them.
        &#34;&#34;&#34;

        # Initialise vector vec
        vec = (0, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*vec, *vec)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            0,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                vec,
                vec,
                res,
                0,
                &#39;Identical Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_opposite(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between two non-zero vectors of equal magnitude but opposite direction

        Two non-zero vectors of equal magnitude but opposite direction
            should make an angle of \\( \\pi \\) radians between them.
        &#34;&#34;&#34;

        # Initialise opposite vectors v1 and v2
        v1 = (0, 1)
        v2 = (0, -1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi,
                &#39;Opposite Non-Zero Vectors&#39;
            )
        )

    def test_angle_between_vectors_in_rad_acute(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(1, 1)`

        Notes
        -----
        ```
          ^
        2 |
          |    (1, 1)
        1 |   x
          |
        0 ----x---------&gt;
               (1, 0)
          0   1   2   3
        ```

        The angle between
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\)
        should be \\( \\frac {\\pi} {4} \\) radians.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 0)
        v2 = (1, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            pi / 4,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                pi / 4,
                &#39;Acute Angle&#39;
            )
        )

    def test_angle_between_vectors_in_rad_obtuse(self) -&gt; None:
        &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(-1, 1)`

        Notes
        -----
        ```
                   ^
                   | 2
        (-1, 1)    |
               x   | 1
                   |
           ------------x---------&gt;
                        (1, 0)
           -2  -1  0   1   2   3
        ```

        The angle between
            \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
            \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\)
        should be \\( \\frac {3 \\pi} {4} \\) radians.
        &#34;&#34;&#34;

        # Initialise vectors v1 and v2
        v1 = (1, 0)
        v2 = (-1, 1)

        # Obtain results
        res = self.node.angle_between_vectors_in_rad(*v1, *v2)

        # Perform assertion checks
        self.assertAlmostEqual(
            res,
            3 * pi / 4,
            places=self._DECIMAL_PRECISION,
            msg=self.error_msg_angle_between_vectors_in_rad(
                v1,
                v2,
                res,
                3 * pi / 4,
                &#39;Obtuse Angle&#39;
            )
        )

    &#34;&#34;&#34;Test cases for are_arms_folded()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_are_arms_folded(
            self,
            left_shoulder: Optional[Coord],
            left_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_shoulder: Optional[Coord],
            right_elbow: Optional[Coord],
            right_wrist: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `are_arms_folded()`

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            The left shoulder coordinate (`x`, `y`) passed into the function
        left_elbow : `Coord`, optional
            The left elbow coordinate (`x`, `y`) passed into the function
        left_wrist : `Coord`, optional
            The left wrist coordinate (`x`, `y`) passed into the function
        right_shoulder : `Coord`, optional
            The right shoulder coordinate (`x`, `y`) passed into the function
        right_elbow : `Coord`, optional
            The right elbow coordinate (`x`, `y`) passed into the function
        right_wrist : `Coord`, optional
            The right wrist coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: are_arms_folded()\n\
                 Test Type: {test}\n\
                Parameters: left_shouler = {left_shoulder}\n\
                            left_elbow = {left_elbow}\n\
                            left_wrist = {left_wrist}\n\
                            right_shoulder = {right_shoulder}\n\
                            right_elbow = {right_elbow}\n\
                            right_wrist = {right_wrist}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_are_arms_folded_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

        The function requires all coordinates to perform the check.
        &#34;&#34;&#34;

        # Initialise coordinates
        pose = [(i, i) for i in range(17)]
        required_coordinates = {
            self.node.KP_LEFT_SHOULDER,
            self.node.KP_LEFT_ELBOW,
            self.node.KP_LEFT_WRIST,
            self.node.KP_RIGHT_SHOULDER,
            self.node.KP_RIGHT_ELBOW,
            self.node.KP_RIGHT_WRIST
        }
        coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

        # Set one or more coordinates to None
        for i, selected_coordinates in enumerate(chain(
                *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
        )):
            left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_LEFT_SHOULDER]
            left_elbow = None if self.node.KP_LEFT_ELBOW in selected_coordinates else \
                coordinates[self.node.KP_LEFT_ELBOW]
            left_wrist = None if self.node.KP_LEFT_WRIST in selected_coordinates else \
                coordinates[self.node.KP_LEFT_WRIST]
            right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_SHOULDER]
            right_elbow = None if self.node.KP_RIGHT_ELBOW in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_ELBOW]
            right_wrist = None if self.node.KP_RIGHT_WRIST in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_WRIST]

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;One or more Missing Inputs (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_touching_face(self) -&gt; None:
        &#34;&#34;&#34;Checks that the arms are not considered folded if the pose is touching the face&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_TOUCHING_FACE):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;Touching Face instead of Folding Arms (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_outstretched_arms(self) -&gt; None:
        &#34;&#34;&#34;Check that outstretched arms are not considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_OUTSTRETCHED_ARMS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    False,
                    f&#39;Arms Outstretched (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_half_cross(self) -&gt; None:
        &#34;&#34;&#34;Checks that half-crossed arms are considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_HALF_CROSS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    True,
                    f&#39;Arms Half-Crossed (Case {i + 1})&#39;
                )
            )

    def test_are_arms_folded_full_cross(self) -&gt; None:
        &#34;&#34;&#34;Checks that fully-crossed arms are considered folded&#34;&#34;&#34;

        for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_FULL_CROSS):

            # Initialise coordinates
            left_shoulder, \
                left_elbow, \
                left_wrist, \
                right_shoulder, \
                right_elbow, \
                right_wrist = coordinates

            # Obtain the result
            res = self.node.are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_are_arms_folded(
                    left_shoulder,
                    left_elbow,
                    left_wrist,
                    right_shoulder,
                    right_elbow,
                    right_wrist,
                    res,
                    True,
                    f&#39;Arms Full-Crossed (Case {i + 1})&#39;
                )
            )

    &#34;&#34;&#34;Test cases for is_face_touched()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_is_face_touched(
            self,
            left_elbow: Optional[Coord],
            right_elbow: Optional[Coord],
            left_wrist: Optional[Coord],
            right_wrist: Optional[Coord],
            nose: Optional[Coord],
            left_eye: Optional[Coord],
            right_eye: Optional[Coord],
            left_ear: Optional[Coord],
            right_ear: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `is_face_touched()`

        Parameters
        ----------
        left_elbow : `Coord`, optional
            The left elbow coordinate (`x`, `y`) passed into the function
        right_elbow : `Coord`, optional
            The right elbow coordinate (`x`, `y`) passed into the function
        left_wrist : `Coord`, optional
            The left wrist coordinate (`x`, `y`) passed into the function
        right_wrist : `Coord`, optional
            The right wrist coordinate (`x`, `y`) passed into the function
        nose : `Coord`, optional
            The nose coordinate (`x`, `y`) passed into the function
        left_eye : `Coord`, optional
            The left eye coordinate (`x`, `y`) passed into the function
        right_eye : `Coord`, optional
            The right eye coordinate (`x`, `y`) passed into the function
        left_ear : `Coord`, optional
            The left ear coordinate (`x`, `y`) passed into the function
        right_ear : `Coord`, optional
            The right ear coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: is_face_touched()\n\
                 Test Type: {test}\n\
                Parameters: left_elbow = {left_elbow}\n\
                            right_elbow = {right_elbow}\n\
                            left_wrist = {left_wrist}\n\
                            right_wrist = {right_wrist}\n\
                            nose = {nose}\n\
                            left_eye = {left_eye}\n\
                            right_eye = {right_eye}\n\
                            left_ear = {left_ear}\n\
                            right_ear = {right_ear}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_is_face_touched_all_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that undefined poses return ``False``&#34;&#34;&#34;

        # Obtain the resut
        res = self.node.is_face_touched(
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_face_touched(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                res,
                False,
                &#39;Touching Face All Missing&#39;
            )
        )

    def test_is_face_touched_negative_some_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses are undefined if all of the keypoints in a required set are undefined

        The function requires that at least one keypoint in each set of keypoints is defined.
        &#34;&#34;&#34;

        # Select coordinates to define
        for i, (limb_coordinate, face_coordinate) in enumerate(((None, (0, 0)), ((0, 0), None))):

            # Initialise coordinates
            left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
            nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    False,
                    f&#39;Touching Face Negative Some Defined (Case {i + 1})&#39;
                )
            )

    def test_is_face_touched_negative_all_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses that do not meet the requirement are considered not touching face&#34;&#34;&#34;

        # Initialise fake coordinates for limb features and facial features
        limb_coordinate = (250, 250)
        face_coordinate = (0, 0)

        # Initialise coordinates
        left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
        nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

        # Obtain the result
        res = self.node.is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear,
                res,
                False,
                &#39;Touching Face Negative All Defined&#39;
            )
        )

    def test_is_face_touched_positive_some_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses are considered as touching face even with some undefined keypoints

        The function is expected to check every possible pair of points
            for one that meets the requirement for touching face.
        &#34;&#34;&#34;

        # Initialise fake coordinates for limb features and facial features
        limb_coordinate = (25, 25)
        face_coordinate = (0, 0)

        # Select coordinates to define
        for case, (i, j) in enumerate(product(range(4), range(4, 9))):

            # Initialise coordinate list
            # Define limb coordinate at index i and facial coordinate at index j
            coordinates = [None] * 9
            coordinates[i] = limb_coordinate  # type: ignore
            coordinates[j] = face_coordinate  # type: ignore

            # Initialise specific coordinates
            left_elbow, \
                right_elbow, \
                left_wrist, \
                right_wrist, \
                nose, \
                left_eye, \
                right_eye, \
                left_ear, \
                right_ear, = coordinates

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    True,
                    f&#39;Touching Face Positive Some Defined (Case {case + 1})&#39;
                )
            )

    def test_is_face_touched_all_defined(self) -&gt; None:
        &#34;&#34;&#34;Checks that poses where the face is touched is considered as touching face&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_TOUCHING_FACE_POSITIVE_CASES_ALL_DEFINED):

            # Initialise coordinates
            left_elbow, \
                right_elbow, \
                left_wrist, \
                right_wrist, \
                nose, \
                left_eye, \
                right_eye, \
                left_ear, \
                right_ear, = coordinates

            # Obtain the result
            res = self.node.is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_face_touched(
                    left_elbow,
                    right_elbow,
                    left_wrist,
                    right_wrist,
                    nose,
                    left_eye,
                    right_eye,
                    left_ear,
                    right_ear,
                    res,
                    True,
                    f&#39;Touching Face All Defined (Case {i + 1})&#39;
                )
            )

    &#34;&#34;&#34;Test cases for is_leaning()&#34;&#34;&#34;  # pylint: disable=pointless-string-statement

    def error_msg_is_leaning(
            self,
            left_shoulder: Optional[Coord],
            right_shoulder: Optional[Coord],
            left_hip: Optional[Coord],
            right_hip: Optional[Coord],
            output: bool,
            expected: bool,
            test: str
    ) -&gt; str:
        &#34;&#34;&#34;Template for unit test error messages for `is_leaning()`

        Parameters
        ----------
        left_shoulder : `Coord`, optional
            The left shoulder coordinate (`x`, `y`) passed into the function
        right_shoulder : `Coord`, optional
            The right shoulder coordinate (`x`, `y`) passed into the function
        left_hip : `Coord`, optional
            The left hip coordinate (`x`, `y`) passed into the function
        right_hip : `Coord`, optional
            The right hip coordinate (`x`, `y`) passed into the function
        output : bool
            The obtained output from the function
        expected : bool
            The expected output of the function
        test : str
            The type of unit test performed

        Returns
        -------
        str
            The formatted error message
        &#34;&#34;&#34;

        return f&#39;\n\
                =============================================\n\
                  Function: is_leaning()\n\
                 Test Type: {test}\n\
                Parameters: left_shouler = {left_shoulder}\n\
                            right_shoulder = {right_shoulder}\n\
                            left_hip = {left_hip}\n\
                            right_hip = {right_hip}\n\
                    Output: {output}\n\
                  Expected: {expected}\n\
                =============================================&#39;

    def test_is_leaning_folded_missing(self) -&gt; None:
        &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

        The function requires all coordinates to perform the check.
        &#34;&#34;&#34;

        # Initialise coordinates
        pose = [(i, i) for i in range(17)]
        required_coordinates = {
            self.node.KP_LEFT_SHOULDER,
            self.node.KP_RIGHT_SHOULDER,
            self.node.KP_LEFT_HIP,
            self.node.KP_RIGHT_HIP
        }
        coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

        # Set one or more coordinates to None
        for i, selected_coordinates in enumerate(chain(
                *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
        )):
            left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_LEFT_SHOULDER]
            right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_SHOULDER]
            left_hip = None if self.node.KP_LEFT_HIP in selected_coordinates else \
                coordinates[self.node.KP_LEFT_HIP]
            right_hip = None if self.node.KP_RIGHT_HIP in selected_coordinates else \
                coordinates[self.node.KP_RIGHT_HIP]

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    False,
                    f&#39;One or more Missing Inputs (Case {i + 1})&#39;
                )
            )

    def test_is_leaning_negative(self) -&gt; None:
        &#34;&#34;&#34;Checks that non-leaning poses are considered not leaning&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_LEANING_NEGATIVE_CASES):

            # Initialise coordinates
            left_shoulder, \
                right_shoulder, \
                left_hip, \
                right_hip = coordinates

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertFalse(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    False,
                    f&#39;Non-Leaning Pose (Case {i + 1})&#39;
                )
            )

    def test_is_leaning_positive(self) -&gt; None:
        &#34;&#34;&#34;Checks that true leaning poses are considered leaning&#34;&#34;&#34;

        for i, coordinates in enumerate(IS_LEANING_POSITIVE_CASES):

            # Initialise coordinates
            left_shoulder, \
                right_shoulder, \
                left_hip, \
                right_hip = coordinates

            # Obtain the result
            res = self.node.is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip
            )

            # Perform assertion check
            self.assertTrue(
                res,
                self.error_msg_is_leaning(
                    left_shoulder,
                    right_shoulder,
                    left_hip,
                    right_hip,
                    res,
                    True,
                    f&#39;Leaning Pose (Case {i + 1})&#39;
                )
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_angle_between_vectors_in_rad"><code class="name flex">
<span>def <span class="ident">error_msg_angle_between_vectors_in_rad</span></span>(<span>self, v1:Â Tuple[int,Â int], v2:Â Tuple[int,Â int], output:Â float, expected:Â float, test:Â str, *, precision:Â intÂ =Â 6) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Template for unit test error messages for <code>angle_between_vectors_in_rad()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v1</code></strong> :&ensp;<code>Coord</code></dt>
<dd>The first vector (<code>x</code>, <code>y</code>) parameter passed into the function</dd>
<dt><strong><code>v2</code></strong> :&ensp;<code>Coord</code></dt>
<dd>The second vector (<code>x</code>, <code>y</code>) parameter passed into the function</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>float</code></dt>
<dd>The obtained output from the function</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>float</code></dt>
<dd>The expected output of the function</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of unit test performed</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code>, default=<code>_DECIMAL_PRECISION</code></dt>
<dd>The expected decimal precision of the outputs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted error message</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_msg_angle_between_vectors_in_rad(
        self,
        v1: Coord,
        v2: Coord,
        output: float,
        expected: float,
        test: str,
        *,
        precision: int = _DECIMAL_PRECISION
) -&gt; str:
    &#34;&#34;&#34;Template for unit test error messages for `angle_between_vectors_in_rad()`

    Parameters
    ----------
    v1 : `Coord`
        The first vector (`x`, `y`) parameter passed into the function
    v2 : `Coord`
        The second vector (`x`, `y`) parameter passed into the function
    output : float
        The obtained output from the function
    expected : float
        The expected output of the function
    test : str
        The type of unit test performed
    precision : int, default=`_DECIMAL_PRECISION`
        The expected decimal precision of the outputs

    Returns
    -------
    str
        The formatted error message
    &#34;&#34;&#34;

    return f&#39;\n\
            =============================================\n\
              Function: angle_between_vectors_in_rad()\n\
             Test Type: {test}\n\
            Parameters: v1 = {v1}, v2 = {v2}\n\
             Precision: {precision}\n\
                Output: {output}\n\
              Expected: {expected}\n\
            =============================================&#39;</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_are_arms_folded"><code class="name flex">
<span>def <span class="ident">error_msg_are_arms_folded</span></span>(<span>self, left_shoulder:Â Optional[Tuple[int,Â int]], left_elbow:Â Optional[Tuple[int,Â int]], left_wrist:Â Optional[Tuple[int,Â int]], right_shoulder:Â Optional[Tuple[int,Â int]], right_elbow:Â Optional[Tuple[int,Â int]], right_wrist:Â Optional[Tuple[int,Â int]], output:Â bool, expected:Â bool, test:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Template for unit test error messages for <code>are_arms_folded()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left shoulder coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left elbow coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left wrist coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right shoulder coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right elbow coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right wrist coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>bool</code></dt>
<dd>The obtained output from the function</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>bool</code></dt>
<dd>The expected output of the function</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of unit test performed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted error message</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_msg_are_arms_folded(
        self,
        left_shoulder: Optional[Coord],
        left_elbow: Optional[Coord],
        left_wrist: Optional[Coord],
        right_shoulder: Optional[Coord],
        right_elbow: Optional[Coord],
        right_wrist: Optional[Coord],
        output: bool,
        expected: bool,
        test: str
) -&gt; str:
    &#34;&#34;&#34;Template for unit test error messages for `are_arms_folded()`

    Parameters
    ----------
    left_shoulder : `Coord`, optional
        The left shoulder coordinate (`x`, `y`) passed into the function
    left_elbow : `Coord`, optional
        The left elbow coordinate (`x`, `y`) passed into the function
    left_wrist : `Coord`, optional
        The left wrist coordinate (`x`, `y`) passed into the function
    right_shoulder : `Coord`, optional
        The right shoulder coordinate (`x`, `y`) passed into the function
    right_elbow : `Coord`, optional
        The right elbow coordinate (`x`, `y`) passed into the function
    right_wrist : `Coord`, optional
        The right wrist coordinate (`x`, `y`) passed into the function
    output : bool
        The obtained output from the function
    expected : bool
        The expected output of the function
    test : str
        The type of unit test performed

    Returns
    -------
    str
        The formatted error message
    &#34;&#34;&#34;

    return f&#39;\n\
            =============================================\n\
              Function: are_arms_folded()\n\
             Test Type: {test}\n\
            Parameters: left_shouler = {left_shoulder}\n\
                        left_elbow = {left_elbow}\n\
                        left_wrist = {left_wrist}\n\
                        right_shoulder = {right_shoulder}\n\
                        right_elbow = {right_elbow}\n\
                        right_wrist = {right_wrist}\n\
                Output: {output}\n\
              Expected: {expected}\n\
            =============================================&#39;</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_face_touched"><code class="name flex">
<span>def <span class="ident">error_msg_is_face_touched</span></span>(<span>self, left_elbow:Â Optional[Tuple[int,Â int]], right_elbow:Â Optional[Tuple[int,Â int]], left_wrist:Â Optional[Tuple[int,Â int]], right_wrist:Â Optional[Tuple[int,Â int]], nose:Â Optional[Tuple[int,Â int]], left_eye:Â Optional[Tuple[int,Â int]], right_eye:Â Optional[Tuple[int,Â int]], left_ear:Â Optional[Tuple[int,Â int]], right_ear:Â Optional[Tuple[int,Â int]], output:Â bool, expected:Â bool, test:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Template for unit test error messages for <code>is_face_touched()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left elbow coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_elbow</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right elbow coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left wrist coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_wrist</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right wrist coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>nose</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The nose coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_eye</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left eye coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_eye</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right eye coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_ear</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left ear coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_ear</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right ear coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>bool</code></dt>
<dd>The obtained output from the function</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>bool</code></dt>
<dd>The expected output of the function</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of unit test performed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted error message</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_msg_is_face_touched(
        self,
        left_elbow: Optional[Coord],
        right_elbow: Optional[Coord],
        left_wrist: Optional[Coord],
        right_wrist: Optional[Coord],
        nose: Optional[Coord],
        left_eye: Optional[Coord],
        right_eye: Optional[Coord],
        left_ear: Optional[Coord],
        right_ear: Optional[Coord],
        output: bool,
        expected: bool,
        test: str
) -&gt; str:
    &#34;&#34;&#34;Template for unit test error messages for `is_face_touched()`

    Parameters
    ----------
    left_elbow : `Coord`, optional
        The left elbow coordinate (`x`, `y`) passed into the function
    right_elbow : `Coord`, optional
        The right elbow coordinate (`x`, `y`) passed into the function
    left_wrist : `Coord`, optional
        The left wrist coordinate (`x`, `y`) passed into the function
    right_wrist : `Coord`, optional
        The right wrist coordinate (`x`, `y`) passed into the function
    nose : `Coord`, optional
        The nose coordinate (`x`, `y`) passed into the function
    left_eye : `Coord`, optional
        The left eye coordinate (`x`, `y`) passed into the function
    right_eye : `Coord`, optional
        The right eye coordinate (`x`, `y`) passed into the function
    left_ear : `Coord`, optional
        The left ear coordinate (`x`, `y`) passed into the function
    right_ear : `Coord`, optional
        The right ear coordinate (`x`, `y`) passed into the function
    output : bool
        The obtained output from the function
    expected : bool
        The expected output of the function
    test : str
        The type of unit test performed

    Returns
    -------
    str
        The formatted error message
    &#34;&#34;&#34;

    return f&#39;\n\
            =============================================\n\
              Function: is_face_touched()\n\
             Test Type: {test}\n\
            Parameters: left_elbow = {left_elbow}\n\
                        right_elbow = {right_elbow}\n\
                        left_wrist = {left_wrist}\n\
                        right_wrist = {right_wrist}\n\
                        nose = {nose}\n\
                        left_eye = {left_eye}\n\
                        right_eye = {right_eye}\n\
                        left_ear = {left_ear}\n\
                        right_ear = {right_ear}\n\
                Output: {output}\n\
              Expected: {expected}\n\
            =============================================&#39;</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_leaning"><code class="name flex">
<span>def <span class="ident">error_msg_is_leaning</span></span>(<span>self, left_shoulder:Â Optional[Tuple[int,Â int]], right_shoulder:Â Optional[Tuple[int,Â int]], left_hip:Â Optional[Tuple[int,Â int]], right_hip:Â Optional[Tuple[int,Â int]], output:Â bool, expected:Â bool, test:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Template for unit test error messages for <code>is_leaning()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>left_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left shoulder coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_shoulder</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right shoulder coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>left_hip</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The left hip coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>right_hip</code></strong> :&ensp;<code>Coord</code>, optional</dt>
<dd>The right hip coordinate (<code>x</code>, <code>y</code>) passed into the function</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>bool</code></dt>
<dd>The obtained output from the function</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>bool</code></dt>
<dd>The expected output of the function</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of unit test performed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted error message</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_msg_is_leaning(
        self,
        left_shoulder: Optional[Coord],
        right_shoulder: Optional[Coord],
        left_hip: Optional[Coord],
        right_hip: Optional[Coord],
        output: bool,
        expected: bool,
        test: str
) -&gt; str:
    &#34;&#34;&#34;Template for unit test error messages for `is_leaning()`

    Parameters
    ----------
    left_shoulder : `Coord`, optional
        The left shoulder coordinate (`x`, `y`) passed into the function
    right_shoulder : `Coord`, optional
        The right shoulder coordinate (`x`, `y`) passed into the function
    left_hip : `Coord`, optional
        The left hip coordinate (`x`, `y`) passed into the function
    right_hip : `Coord`, optional
        The right hip coordinate (`x`, `y`) passed into the function
    output : bool
        The obtained output from the function
    expected : bool
        The expected output of the function
    test : str
        The type of unit test performed

    Returns
    -------
    str
        The formatted error message
    &#34;&#34;&#34;

    return f&#39;\n\
            =============================================\n\
              Function: is_leaning()\n\
             Test Type: {test}\n\
            Parameters: left_shouler = {left_shoulder}\n\
                        right_shoulder = {right_shoulder}\n\
                        left_hip = {left_hip}\n\
                        right_hip = {right_hip}\n\
                Output: {output}\n\
              Expected: {expected}\n\
            =============================================&#39;</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialises the Node object used for unit testing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self) -&gt; None:
    &#34;&#34;&#34;Initialises the Node object used for unit testing&#34;&#34;&#34;

    # Initialise YML filepath
    filepath = &#39;analysis_video_pipeline/src/custom_nodes/configs/dabble/movement.yml&#39;

    # Obtain Node instance
    with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as config_file:
        config = safe_load(config_file)
        self.node = Node(config=config)</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_acute"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_acute</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the resultant angle between vectors <code>(1, 0)</code> and <code>(1, 1)</code></p>
<h2 id="notes">Notes</h2>
<pre><code>  ^
2 |
  |    (1, 1)
1 |   x
  |
0 ----x---------&gt;
       (1, 0)
  0   1   2   3
</code></pre>
<p>The angle between
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } = \begin{pmatrix} 1 \\ 0 \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{1} } = \begin{pmatrix} 1 \\ 0 \end{pmatrix} </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } = \begin{pmatrix} 1 \\ 1 \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{2} } = \begin{pmatrix} 1 \\ 1 \end{pmatrix} </script></span>
should be <span><span class="MathJax_Preview"> \frac {\pi} {4} </span><script type="math/tex"> \frac {\pi} {4} </script></span> radians.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_acute(self) -&gt; None:
    &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(1, 1)`

    Notes
    -----
    ```
      ^
    2 |
      |    (1, 1)
    1 |   x
      |
    0 ----x---------&gt;
           (1, 0)
      0   1   2   3
    ```

    The angle between
        \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
        \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\)
    should be \\( \\frac {\\pi} {4} \\) radians.
    &#34;&#34;&#34;

    # Initialise vectors v1 and v2
    v1 = (1, 0)
    v2 = (1, 1)

    # Obtain results
    res = self.node.angle_between_vectors_in_rad(*v1, *v2)

    # Perform assertion checks
    self.assertAlmostEqual(
        res,
        pi / 4,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            v1,
            v2,
            res,
            pi / 4,
            &#39;Acute Angle&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_associativity"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_associativity</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the function is associative</p>
<p>The order in which the vectors are passed into the function should not matter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_associativity(self) -&gt; None:
    &#34;&#34;&#34;Checks that the function is associative

    The order in which the vectors are passed into the function should not matter.
    &#34;&#34;&#34;

    # Initialise vectors v1 and v2
    v1 = (1, 3)
    v2 = (-2, 5)

    # Obtain results
    r1 = self.node.angle_between_vectors_in_rad(*v1, *v2)
    r2 = self.node.angle_between_vectors_in_rad(*v2, *v1)

    # Perform assertion checks
    self.assertAlmostEqual(
        r1,
        r2,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            v1,
            v2,
            r1,
            r2,
            &#39;Function Associativity&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_identical"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_identical</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the resultant angle between two identical non-zero vectors</p>
<p>Two identical non-zero vectors should make an angle of <code>0</code> radians between them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_identical(self) -&gt; None:
    &#34;&#34;&#34;Checks the resultant angle between two identical non-zero vectors

    Two identical non-zero vectors should make an angle of `0` radians between them.
    &#34;&#34;&#34;

    # Initialise vector vec
    vec = (0, 1)

    # Obtain results
    res = self.node.angle_between_vectors_in_rad(*vec, *vec)

    # Perform assertion checks
    self.assertAlmostEqual(
        res,
        0,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            vec,
            vec,
            res,
            0,
            &#39;Identical Non-Zero Vectors&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_obtuse"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_obtuse</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the resultant angle between vectors <code>(1, 0)</code> and <code>(-1, 1)</code></p>
<h2 id="notes">Notes</h2>
<pre><code>           ^
           | 2
(-1, 1)    |
       x   | 1
           |
   ------------x---------&gt;
                (1, 0)
   -2  -1  0   1   2   3
</code></pre>
<p>The angle between
<span><span class="MathJax_Preview"> \overrightarrow{ V_{1} } = \begin{pmatrix} 1 \\ 0 \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{1} } = \begin{pmatrix} 1 \\ 0 \end{pmatrix} </script></span> and
<span><span class="MathJax_Preview"> \overrightarrow{ V_{2} } = \begin{pmatrix} -1 \\ 1 \end{pmatrix} </span><script type="math/tex"> \overrightarrow{ V_{2} } = \begin{pmatrix} -1 \\ 1 \end{pmatrix} </script></span>
should be <span><span class="MathJax_Preview"> \frac {3 \pi} {4} </span><script type="math/tex"> \frac {3 \pi} {4} </script></span> radians.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_obtuse(self) -&gt; None:
    &#34;&#34;&#34;Checks the resultant angle between vectors `(1, 0)` and `(-1, 1)`

    Notes
    -----
    ```
               ^
               | 2
    (-1, 1)    |
           x   | 1
               |
       ------------x---------&gt;
                    (1, 0)
       -2  -1  0   1   2   3
    ```

    The angle between
        \\( \\overrightarrow{ V_{1} } = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\) and
        \\( \\overrightarrow{ V_{2} } = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\)
    should be \\( \\frac {3 \\pi} {4} \\) radians.
    &#34;&#34;&#34;

    # Initialise vectors v1 and v2
    v1 = (1, 0)
    v2 = (-1, 1)

    # Obtain results
    res = self.node.angle_between_vectors_in_rad(*v1, *v2)

    # Perform assertion checks
    self.assertAlmostEqual(
        res,
        3 * pi / 4,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            v1,
            v2,
            res,
            3 * pi / 4,
            &#39;Obtuse Angle&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_opposite"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_opposite</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the resultant angle between two non-zero vectors of equal magnitude but opposite direction</p>
<p>Two non-zero vectors of equal magnitude but opposite direction
should make an angle of <span><span class="MathJax_Preview"> \pi </span><script type="math/tex"> \pi </script></span> radians between them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_opposite(self) -&gt; None:
    &#34;&#34;&#34;Checks the resultant angle between two non-zero vectors of equal magnitude but opposite direction

    Two non-zero vectors of equal magnitude but opposite direction
        should make an angle of \\( \\pi \\) radians between them.
    &#34;&#34;&#34;

    # Initialise opposite vectors v1 and v2
    v1 = (0, 1)
    v2 = (0, -1)

    # Obtain results
    res = self.node.angle_between_vectors_in_rad(*v1, *v2)

    # Perform assertion checks
    self.assertAlmostEqual(
        res,
        pi,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            v1,
            v2,
            res,
            pi,
            &#39;Opposite Non-Zero Vectors&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_orthogonal"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_orthogonal</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the resultant angle between two orthogonal non-zero vectors</p>
<p>Two non-zero orthogonal vectors should make an angle of
<span><span class="MathJax_Preview"> \frac {\pi} {2} </span><script type="math/tex"> \frac {\pi} {2} </script></span> radians between them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_orthogonal(self) -&gt; None:
    &#34;&#34;&#34;Checks the resultant angle between two orthogonal non-zero vectors

    Two non-zero orthogonal vectors should make an angle of
        \\( \\frac {\\pi} {2} \\) radians between them.
    &#34;&#34;&#34;

    # Initialise vectors v1 and v2 that are orthogonal to each other
    v1 = (0, 1)
    v2 = (1, 0)

    # Obtain results
    res = self.node.angle_between_vectors_in_rad(*v1, *v2)

    # Perform assertion checks
    self.assertAlmostEqual(
        res,
        pi / 2,
        places=self._DECIMAL_PRECISION,
        msg=self.error_msg_angle_between_vectors_in_rad(
            v1,
            v2,
            res,
            pi / 2,
            &#39;Orthogonal Non-Zero Vectors&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_zero"><code class="name flex">
<span>def <span class="ident">test_angle_between_vectors_in_rad_zero</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if passing a zero vector into the function results in an error</p>
<p>The function is expected to output <code>Node.ERROR_OUTPUT</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_angle_between_vectors_in_rad_zero(self) -&gt; None:
    &#34;&#34;&#34;Checks if passing a zero vector into the function results in an error

    The function is expected to output ``Node.ERROR_OUTPUT``.
    &#34;&#34;&#34;

    # Initialise zero vector zero and non-zero vector vec
    zero = (0, 0)
    vec = (0, 1)

    # Obtain results
    r1 = self.node.angle_between_vectors_in_rad(*zero, *vec)
    r2 = self.node.angle_between_vectors_in_rad(*vec, *zero)
    r3 = self.node.angle_between_vectors_in_rad(*zero, *zero)

    # Perform assertion checks
    self.assertEqual(
        r1,
        self.node.ERROR_OUTPUT,
        msg=self.error_msg_angle_between_vectors_in_rad(
            zero,
            vec,
            r1,
            self.node.ERROR_OUTPUT,
            &#39;First Parameter is Zero Vector&#39;,
            precision=0
        )
    )
    self.assertEqual(
        r2,
        self.node.ERROR_OUTPUT,
        msg=self.error_msg_angle_between_vectors_in_rad(
            vec,
            zero,
            r2,
            self.node.ERROR_OUTPUT,
            &#39;Second Parameter is Zero Vector&#39;,
            precision=0
        )
    )
    self.assertEqual(
        r3,
        self.node.ERROR_OUTPUT,
        msg=self.error_msg_angle_between_vectors_in_rad(
            zero,
            zero,
            r3,
            self.node.ERROR_OUTPUT,
            &#39;Both Parameters are Zero Vectors&#39;,
            precision=0
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_full_cross"><code class="name flex">
<span>def <span class="ident">test_are_arms_folded_full_cross</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that fully-crossed arms are considered folded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_are_arms_folded_full_cross(self) -&gt; None:
    &#34;&#34;&#34;Checks that fully-crossed arms are considered folded&#34;&#34;&#34;

    for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_FULL_CROSS):

        # Initialise coordinates
        left_shoulder, \
            left_elbow, \
            left_wrist, \
            right_shoulder, \
            right_elbow, \
            right_wrist = coordinates

        # Obtain the result
        res = self.node.are_arms_folded(
            left_shoulder,
            left_elbow,
            left_wrist,
            right_shoulder,
            right_elbow,
            right_wrist
        )

        # Perform assertion check
        self.assertTrue(
            res,
            self.error_msg_are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist,
                res,
                True,
                f&#39;Arms Full-Crossed (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_half_cross"><code class="name flex">
<span>def <span class="ident">test_are_arms_folded_half_cross</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that half-crossed arms are considered folded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_are_arms_folded_half_cross(self) -&gt; None:
    &#34;&#34;&#34;Checks that half-crossed arms are considered folded&#34;&#34;&#34;

    for i, coordinates in enumerate(ARE_ARMS_FOLDED_POSITIVE_CASES_HALF_CROSS):

        # Initialise coordinates
        left_shoulder, \
            left_elbow, \
            left_wrist, \
            right_shoulder, \
            right_elbow, \
            right_wrist = coordinates

        # Obtain the result
        res = self.node.are_arms_folded(
            left_shoulder,
            left_elbow,
            left_wrist,
            right_shoulder,
            right_elbow,
            right_wrist
        )

        # Perform assertion check
        self.assertTrue(
            res,
            self.error_msg_are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist,
                res,
                True,
                f&#39;Arms Half-Crossed (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_missing"><code class="name flex">
<span>def <span class="ident">test_are_arms_folded_missing</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the function returns <code>False</code> if at least one input is missing</p>
<p>The function requires all coordinates to perform the check.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_are_arms_folded_missing(self) -&gt; None:
    &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

    The function requires all coordinates to perform the check.
    &#34;&#34;&#34;

    # Initialise coordinates
    pose = [(i, i) for i in range(17)]
    required_coordinates = {
        self.node.KP_LEFT_SHOULDER,
        self.node.KP_LEFT_ELBOW,
        self.node.KP_LEFT_WRIST,
        self.node.KP_RIGHT_SHOULDER,
        self.node.KP_RIGHT_ELBOW,
        self.node.KP_RIGHT_WRIST
    }
    coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

    # Set one or more coordinates to None
    for i, selected_coordinates in enumerate(chain(
            *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
    )):
        left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
            coordinates[self.node.KP_LEFT_SHOULDER]
        left_elbow = None if self.node.KP_LEFT_ELBOW in selected_coordinates else \
            coordinates[self.node.KP_LEFT_ELBOW]
        left_wrist = None if self.node.KP_LEFT_WRIST in selected_coordinates else \
            coordinates[self.node.KP_LEFT_WRIST]
        right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
            coordinates[self.node.KP_RIGHT_SHOULDER]
        right_elbow = None if self.node.KP_RIGHT_ELBOW in selected_coordinates else \
            coordinates[self.node.KP_RIGHT_ELBOW]
        right_wrist = None if self.node.KP_RIGHT_WRIST in selected_coordinates else \
            coordinates[self.node.KP_RIGHT_WRIST]

        # Obtain the result
        res = self.node.are_arms_folded(
            left_shoulder,
            left_elbow,
            left_wrist,
            right_shoulder,
            right_elbow,
            right_wrist
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist,
                res,
                False,
                f&#39;One or more Missing Inputs (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_outstretched_arms"><code class="name flex">
<span>def <span class="ident">test_are_arms_folded_outstretched_arms</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Check that outstretched arms are not considered folded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_are_arms_folded_outstretched_arms(self) -&gt; None:
    &#34;&#34;&#34;Check that outstretched arms are not considered folded&#34;&#34;&#34;

    for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_OUTSTRETCHED_ARMS):

        # Initialise coordinates
        left_shoulder, \
            left_elbow, \
            left_wrist, \
            right_shoulder, \
            right_elbow, \
            right_wrist = coordinates

        # Obtain the result
        res = self.node.are_arms_folded(
            left_shoulder,
            left_elbow,
            left_wrist,
            right_shoulder,
            right_elbow,
            right_wrist
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist,
                res,
                False,
                f&#39;Arms Outstretched (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_touching_face"><code class="name flex">
<span>def <span class="ident">test_are_arms_folded_touching_face</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the arms are not considered folded if the pose is touching the face</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_are_arms_folded_touching_face(self) -&gt; None:
    &#34;&#34;&#34;Checks that the arms are not considered folded if the pose is touching the face&#34;&#34;&#34;

    for i, coordinates in enumerate(ARE_ARMS_FOLDED_NEGATIVE_CASES_TOUCHING_FACE):

        # Initialise coordinates
        left_shoulder, \
            left_elbow, \
            left_wrist, \
            right_shoulder, \
            right_elbow, \
            right_wrist = coordinates

        # Obtain the result
        res = self.node.are_arms_folded(
            left_shoulder,
            left_elbow,
            left_wrist,
            right_shoulder,
            right_elbow,
            right_wrist
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_are_arms_folded(
                left_shoulder,
                left_elbow,
                left_wrist,
                right_shoulder,
                right_elbow,
                right_wrist,
                res,
                False,
                f&#39;Touching Face instead of Folding Arms (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_defined"><code class="name flex">
<span>def <span class="ident">test_is_face_touched_all_defined</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that poses where the face is touched is considered as touching face</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_face_touched_all_defined(self) -&gt; None:
    &#34;&#34;&#34;Checks that poses where the face is touched is considered as touching face&#34;&#34;&#34;

    for i, coordinates in enumerate(IS_TOUCHING_FACE_POSITIVE_CASES_ALL_DEFINED):

        # Initialise coordinates
        left_elbow, \
            right_elbow, \
            left_wrist, \
            right_wrist, \
            nose, \
            left_eye, \
            right_eye, \
            left_ear, \
            right_ear, = coordinates

        # Obtain the result
        res = self.node.is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear
        )

        # Perform assertion check
        self.assertTrue(
            res,
            self.error_msg_is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear,
                res,
                True,
                f&#39;Touching Face All Defined (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_missing"><code class="name flex">
<span>def <span class="ident">test_is_face_touched_all_missing</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that undefined poses return <code>False</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_face_touched_all_missing(self) -&gt; None:
    &#34;&#34;&#34;Checks that undefined poses return ``False``&#34;&#34;&#34;

    # Obtain the resut
    res = self.node.is_face_touched(
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None
    )

    # Perform assertion check
    self.assertFalse(
        res,
        self.error_msg_is_face_touched(
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            res,
            False,
            &#39;Touching Face All Missing&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_all_defined"><code class="name flex">
<span>def <span class="ident">test_is_face_touched_negative_all_defined</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that poses that do not meet the requirement are considered not touching face</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_face_touched_negative_all_defined(self) -&gt; None:
    &#34;&#34;&#34;Checks that poses that do not meet the requirement are considered not touching face&#34;&#34;&#34;

    # Initialise fake coordinates for limb features and facial features
    limb_coordinate = (250, 250)
    face_coordinate = (0, 0)

    # Initialise coordinates
    left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
    nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

    # Obtain the result
    res = self.node.is_face_touched(
        left_elbow,
        right_elbow,
        left_wrist,
        right_wrist,
        nose,
        left_eye,
        right_eye,
        left_ear,
        right_ear
    )

    # Perform assertion check
    self.assertFalse(
        res,
        self.error_msg_is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear,
            res,
            False,
            &#39;Touching Face Negative All Defined&#39;
        )
    )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_some_defined"><code class="name flex">
<span>def <span class="ident">test_is_face_touched_negative_some_defined</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that poses are undefined if all of the keypoints in a required set are undefined</p>
<p>The function requires that at least one keypoint in each set of keypoints is defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_face_touched_negative_some_defined(self) -&gt; None:
    &#34;&#34;&#34;Checks that poses are undefined if all of the keypoints in a required set are undefined

    The function requires that at least one keypoint in each set of keypoints is defined.
    &#34;&#34;&#34;

    # Select coordinates to define
    for i, (limb_coordinate, face_coordinate) in enumerate(((None, (0, 0)), ((0, 0), None))):

        # Initialise coordinates
        left_elbow = right_elbow = left_wrist = right_wrist = limb_coordinate
        nose = left_eye = right_eye = left_ear = right_ear = face_coordinate

        # Obtain the result
        res = self.node.is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear,
                res,
                False,
                f&#39;Touching Face Negative Some Defined (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_positive_some_defined"><code class="name flex">
<span>def <span class="ident">test_is_face_touched_positive_some_defined</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that poses are considered as touching face even with some undefined keypoints</p>
<p>The function is expected to check every possible pair of points
for one that meets the requirement for touching face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_face_touched_positive_some_defined(self) -&gt; None:
    &#34;&#34;&#34;Checks that poses are considered as touching face even with some undefined keypoints

    The function is expected to check every possible pair of points
        for one that meets the requirement for touching face.
    &#34;&#34;&#34;

    # Initialise fake coordinates for limb features and facial features
    limb_coordinate = (25, 25)
    face_coordinate = (0, 0)

    # Select coordinates to define
    for case, (i, j) in enumerate(product(range(4), range(4, 9))):

        # Initialise coordinate list
        # Define limb coordinate at index i and facial coordinate at index j
        coordinates = [None] * 9
        coordinates[i] = limb_coordinate  # type: ignore
        coordinates[j] = face_coordinate  # type: ignore

        # Initialise specific coordinates
        left_elbow, \
            right_elbow, \
            left_wrist, \
            right_wrist, \
            nose, \
            left_eye, \
            right_eye, \
            left_ear, \
            right_ear, = coordinates

        # Obtain the result
        res = self.node.is_face_touched(
            left_elbow,
            right_elbow,
            left_wrist,
            right_wrist,
            nose,
            left_eye,
            right_eye,
            left_ear,
            right_ear
        )

        # Perform assertion check
        self.assertTrue(
            res,
            self.error_msg_is_face_touched(
                left_elbow,
                right_elbow,
                left_wrist,
                right_wrist,
                nose,
                left_eye,
                right_eye,
                left_ear,
                right_ear,
                res,
                True,
                f&#39;Touching Face Positive Some Defined (Case {case + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_folded_missing"><code class="name flex">
<span>def <span class="ident">test_is_leaning_folded_missing</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the function returns <code>False</code> if at least one input is missing</p>
<p>The function requires all coordinates to perform the check.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_leaning_folded_missing(self) -&gt; None:
    &#34;&#34;&#34;Checks that the function returns ``False`` if at least one input is missing

    The function requires all coordinates to perform the check.
    &#34;&#34;&#34;

    # Initialise coordinates
    pose = [(i, i) for i in range(17)]
    required_coordinates = {
        self.node.KP_LEFT_SHOULDER,
        self.node.KP_RIGHT_SHOULDER,
        self.node.KP_LEFT_HIP,
        self.node.KP_RIGHT_HIP
    }
    coordinates = {joint: coordinate for joint, coordinate in enumerate(pose) if joint in required_coordinates}

    # Set one or more coordinates to None
    for i, selected_coordinates in enumerate(chain(
            *(combinations(required_coordinates, num + 1) for num in range(len(required_coordinates)))
    )):
        left_shoulder = None if self.node.KP_LEFT_SHOULDER in selected_coordinates else \
            coordinates[self.node.KP_LEFT_SHOULDER]
        right_shoulder = None if self.node.KP_RIGHT_SHOULDER in selected_coordinates else \
            coordinates[self.node.KP_RIGHT_SHOULDER]
        left_hip = None if self.node.KP_LEFT_HIP in selected_coordinates else \
            coordinates[self.node.KP_LEFT_HIP]
        right_hip = None if self.node.KP_RIGHT_HIP in selected_coordinates else \
            coordinates[self.node.KP_RIGHT_HIP]

        # Obtain the result
        res = self.node.is_leaning(
            left_shoulder,
            right_shoulder,
            left_hip,
            right_hip
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip,
                res,
                False,
                f&#39;One or more Missing Inputs (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_negative"><code class="name flex">
<span>def <span class="ident">test_is_leaning_negative</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that non-leaning poses are considered not leaning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_leaning_negative(self) -&gt; None:
    &#34;&#34;&#34;Checks that non-leaning poses are considered not leaning&#34;&#34;&#34;

    for i, coordinates in enumerate(IS_LEANING_NEGATIVE_CASES):

        # Initialise coordinates
        left_shoulder, \
            right_shoulder, \
            left_hip, \
            right_hip = coordinates

        # Obtain the result
        res = self.node.is_leaning(
            left_shoulder,
            right_shoulder,
            left_hip,
            right_hip
        )

        # Perform assertion check
        self.assertFalse(
            res,
            self.error_msg_is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip,
                res,
                False,
                f&#39;Non-Leaning Pose (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
<dt id="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_positive"><code class="name flex">
<span>def <span class="ident">test_is_leaning_positive</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that true leaning poses are considered leaning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_leaning_positive(self) -&gt; None:
    &#34;&#34;&#34;Checks that true leaning poses are considered leaning&#34;&#34;&#34;

    for i, coordinates in enumerate(IS_LEANING_POSITIVE_CASES):

        # Initialise coordinates
        left_shoulder, \
            right_shoulder, \
            left_hip, \
            right_hip = coordinates

        # Obtain the result
        res = self.node.is_leaning(
            left_shoulder,
            right_shoulder,
            left_hip,
            right_hip
        )

        # Perform assertion check
        self.assertTrue(
            res,
            self.error_msg_is_leaning(
                left_shoulder,
                right_shoulder,
                left_hip,
                right_hip,
                res,
                True,
                f&#39;Leaning Pose (Case {i + 1})&#39;
            )
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#usage">Usage</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests" href="index.html">SpeakEase.analysis_video_pipeline.tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode">TestNode</a></code></h4>
<ul class="">
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_angle_between_vectors_in_rad" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_angle_between_vectors_in_rad">error_msg_angle_between_vectors_in_rad</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_are_arms_folded" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_are_arms_folded">error_msg_are_arms_folded</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_face_touched" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_face_touched">error_msg_is_face_touched</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_leaning" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.error_msg_is_leaning">error_msg_is_leaning</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.setUp" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.setUp">setUp</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_acute" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_acute">test_angle_between_vectors_in_rad_acute</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_associativity" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_associativity">test_angle_between_vectors_in_rad_associativity</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_identical" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_identical">test_angle_between_vectors_in_rad_identical</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_obtuse" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_obtuse">test_angle_between_vectors_in_rad_obtuse</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_opposite" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_opposite">test_angle_between_vectors_in_rad_opposite</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_orthogonal" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_orthogonal">test_angle_between_vectors_in_rad_orthogonal</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_zero" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_angle_between_vectors_in_rad_zero">test_angle_between_vectors_in_rad_zero</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_full_cross" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_full_cross">test_are_arms_folded_full_cross</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_half_cross" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_half_cross">test_are_arms_folded_half_cross</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_missing" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_missing">test_are_arms_folded_missing</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_outstretched_arms" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_outstretched_arms">test_are_arms_folded_outstretched_arms</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_touching_face" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_are_arms_folded_touching_face">test_are_arms_folded_touching_face</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_defined" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_defined">test_is_face_touched_all_defined</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_missing" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_all_missing">test_is_face_touched_all_missing</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_all_defined" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_all_defined">test_is_face_touched_negative_all_defined</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_some_defined" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_negative_some_defined">test_is_face_touched_negative_some_defined</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_positive_some_defined" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_face_touched_positive_some_defined">test_is_face_touched_positive_some_defined</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_folded_missing" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_folded_missing">test_is_leaning_folded_missing</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_negative" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_negative">test_is_leaning_negative</a></code></li>
<li><code><a title="SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_positive" href="#SpeakEase.analysis_video_pipeline.tests.test_node.TestNode.test_is_leaning_positive">test_is_leaning_positive</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>